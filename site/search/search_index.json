{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Welcome to go-leetcode","text":"<p>A site for leetcoder with golang</p>"},{"location":"hot100/array/LC189/","title":"LC189 - \u8f6e\u8f6c\u6570\u7ec4","text":"RotateArray.go<pre><code>package Array\n\nfunc rotate(nums []int, k int) {\n    size := len(nums)\n    k = k % size\n    reverse(nums, 0, size-1)\n    reverse(nums, 0, k-1)\n    reverse(nums, k, size-1)\n}\n\nfunc reverse(nums []int, start, end int) {\n    for i, j := start, end; i &lt; j; i, j = i+1, j-1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n}\n</code></pre> <p>\u6ce8\u610f\u9700\u8981\u5148\u5bf9 k \u53d6\u6a21</p>"},{"location":"hot100/array/LC238/","title":"LC238 - \u9664\u81ea\u8eab\u5916\u6570\u7ec4\u7684\u4e58\u79ef","text":"ProductOfArrayExceptSelf.go<pre><code>package Array\n\nfunc productExceptSelf(nums []int) []int {\n    prefixSum, suffixSum := make([]int, len(nums)), make([]int, len(nums))\n    prefixSum[0], suffixSum[len(nums)-1] = nums[0], nums[len(nums)-1]\n    for i := 1; i &lt; len(nums); i++ {\n        prefixSum[i] = prefixSum[i-1] * nums[i]\n    }\n    for i := len(nums) - 2; i &gt;= 0; i-- {\n        suffixSum[i] = suffixSum[i+1] * nums[i]\n    }\n    result := make([]int, len(nums))\n    for i := 1; i &lt; len(nums)-1; i++ {\n        result[i] = prefixSum[i-1] * suffixSum[i+1]\n    }\n    result[0] = suffixSum[1]\n    result[len(nums)-1] = prefixSum[len(nums)-2]\n    return result\n}\n</code></pre>"},{"location":"hot100/array/LC41/","title":"LC41 - \u7f3a\u5931\u7684\u7b2c\u4e00\u4e2a\u6b63\u6570","text":"FirstMissingPositive.go<pre><code>package Array\n\n// \u53cc\u6307\u9488\u89e3\u6cd5, \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc firstMissingPositive(nums []int) int {\n    size := len(nums)\n    l, r := 0, size\n    // nums[0...l-1] -&gt; 1 2 3 ... l, \u8868\u793a\u5df2\u5f52\u4f4d\u7684\u90e8\u5206\n    // nums[r...size-1] -&gt; \u8868\u793a\u5783\u573e\u533a\uff0c\u540c\u65f6\u8868\u793a\u5728\u6700\u597d\u60c5\u51b5\u4e0b1-r\u8fd9\u4e9b\u6570\u5b57\u53ef\u4ee5\u5168\u90e8\u6536\u96c6\n    for l &lt; r {\n        if nums[l] == l+1 {\n            // (1) \u5df2\u5f52\u4f4d -&gt; \u7ee7\u7eed\u5224\u65ad\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\n            l++\n        } else if nums[l] &lt;= l || nums[l] &gt; r || nums[nums[l]-1] == nums[l] {\n            // (2) \u5df2\u8d8a\u754c\u6216\u76ee\u6807\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u5df2\u5f52\u4f4d -&gt; \u5c06\u5f53\u524d\u6570\u5b57\u5206\u914d\u5230\u5783\u573e\u533a\n            nums[l], nums[r-1] = nums[r-1], nums[l]\n            r--\n        } else {\n            // (3) \u4e00\u822c\u60c5\u51b5 -&gt; \u5c06\u5f53\u524d\u6570\u5b57\u4e0e\u76ee\u6807\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u8fdb\u884c\u4ea4\u6362\n            nums[l], nums[nums[l]-1] = nums[nums[l]-1], nums[l]\n        }\n    }\n    return l + 1\n}\n</code></pre> <p>MEX\u95ee\u9898\uff0c\u6ce8\u91ca\u5df2\u7ecf\u5199\u5f97\u5f88\u6e05\u695a\uff0c\u5f3a\u63a8\u5de6\u795e\u7b97\u6cd5\u8bb2\u89e3</p>"},{"location":"hot100/array/LC53/","title":"LC53 - \u6700\u5927\u5b50\u6570\u7ec4\u548c","text":"MaximumSubarray.go<pre><code>package Array\n\nimport \"math\"\n\nfunc maxSubArray(nums []int) int {\n    nums = append([]int{0}, nums...)\n    prefixSum := make([]int, len(nums))\n    for i := 1; i &lt; len(nums); i++ {\n        prefixSum[i] = prefixSum[i-1] + nums[i]\n    }\n    minPrefixSum := 0\n    maxSum := math.MinInt\n    for i := 1; i &lt; len(nums); i++ {\n        maxSum = max(maxSum, prefixSum[i]-minPrefixSum)\n        minPrefixSum = min(minPrefixSum, prefixSum[i])\n    }\n    return maxSum\n}\n</code></pre> <p>\u524d\u7f00\u548c</p>"},{"location":"hot100/array/LC56/","title":"LC56 - \u5408\u5e76\u533a\u95f4","text":"MergeIntervals.go<pre><code>package Array\n\nimport (\n    \"cmp\"\n    \"slices\"\n)\n\nfunc merge(intervals [][]int) [][]int {\n    slices.SortFunc(intervals, func(a, b []int) int {\n        return cmp.Compare(a[0], b[0])\n    })\n    result := make([][]int, 0)\n    curStart := intervals[0][0]\n    curEnd := intervals[0][1]\n    for i := 0; i &lt; len(intervals); i++ {\n        if curEnd &gt;= intervals[i][0] {\n            curEnd = max(curEnd, intervals[i][1])\n        } else {\n            result = append(result, []int{curStart, curEnd})\n            curStart = intervals[i][0]\n            curEnd = intervals[i][1]\n        }\n    }\n    result = append(result, []int{curStart, curEnd})\n    return result\n}\n</code></pre>"},{"location":"hot100/doublePointers/LC11/","title":"LC11 - \u76db\u6c34\u6700\u591a\u7684\u5bb9\u5668","text":"ContainerWithMostWater.go<pre><code>package DoublePointers\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc maxArea(height []int) int {\n    left, right := 0, len(height)-1\n    result := (right - left) * min(height[left], height[right])\n    for left &lt; right {\n        if height[left] &lt;= height[right] {\n            tmp := height[left]\n            for left &lt; right &amp;&amp; height[left] &lt;= tmp {\n                left++\n            }\n        } else {\n            tmp := height[right]\n            for left &lt; right &amp;&amp; height[right] &lt;= tmp {\n                right--\n            }\n        }\n        result = max(result, (right-left)*min(height[left], height[right]))\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/doublePointers/LC15/","title":"LC15 - \u4e09\u6570\u4e4b\u548c","text":"ThreeSum.go<pre><code>package DoublePointers\n\nimport \"slices\"\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n^2), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc threeSum(nums []int) [][]int {\n    slices.Sort(nums)\n    result := make([][]int, 0)\n    for i := 0; i &lt; len(nums)-2; i = next(i, nums) {\n        j, k := i+1, len(nums)-1\n        for j &lt; k {\n            if nums[i]+nums[j]+nums[k] == 0 {\n                result = append(result, []int{nums[i], nums[j], nums[k]})\n                j = next(j, nums)\n                k = prev(k, nums)\n            } else if nums[i]+nums[j]+nums[k] &lt; 0 {\n                j = next(j, nums)\n            } else {\n                k = prev(k, nums)\n            }\n        }\n    }\n    return result\n}\n\nfunc next(i int, nums []int) int {\n    length := len(nums)\n    for ; i+1 &lt; length &amp;&amp; nums[i] == nums[i+1]; i++ {\n    }\n    return i + 1\n}\n\nfunc prev(i int, nums []int) int {\n    for ; i-1 &gt;= 0 &amp;&amp; nums[i] == nums[i-1]; i-- {\n    }\n    return i - 1\n}\n</code></pre> <p>\u672c\u9898\u4e0eLC1\u7684\u6700\u672c\u8d28\u533a\u522b\u5728\u4e8e\u53ea\u9700\u8fd4\u56de\u6570\u503c\u800c\u4e0d\u7528\u539f\u59cb\u6570\u7ec4\u7684\u4e0b\u6807\uff0c\u56e0\u6b64\u975e\u5e38\u9002\u5408\u4f7f\u7528\u53cc\u6307\u9488\u3002</p> <p>\u4e3a\u4e86\u5b9e\u73b0\u5bf9\u7ed3\u679c\u7684\u53bb\u91cd\uff0c\u9700\u8981\u5b9e\u73b0<code>next</code>\u51fd\u6570\u548c<code>prev</code>\u51fd\u6570\u4ee5\u53d6\u4ee3\u539f\u672c\u7684--\u548c++\u3002</p>"},{"location":"hot100/doublePointers/LC283/","title":"LC283 - \u79fb\u52a8\u96f6","text":"MoveZeroes.go<pre><code>package DoublePointers\n\nfunc moveZeroes(nums []int) {\n    moveZeroes2(nums)\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n^2), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc moveZeroes1(nums []int) {\n    left, right := 0, len(nums)-1\n    for left &lt;= right {\n        if nums[left] == 0 {\n            moveToEnd(nums, left, right)\n            right--\n        } else {\n            left++\n        }\n    }\n}\n\nfunc moveToEnd(nums []int, left int, right int) {\n    tmp := nums[left]\n    for i := left; i &lt; right; i++ {\n        nums[i] = nums[i+1]\n    }\n    nums[right] = tmp\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc moveZeroes2(nums []int) {\n    left, right := 0, 0\n    for right &lt; len(nums) {\n        if nums[right] != 0 {\n            nums[left], nums[right] = nums[right], nums[left]\n            left++\n        }\n        right++\n    }\n}\n</code></pre> <p><code>moveZeroes1</code>\u65b9\u6cd5\u4e2d\uff0c\u53f3\u4fa7\u6307\u9488\u7ef4\u62a4\u96f6\u533a\uff0c\u7531\u4e8e\u9898\u76ee\u8981\u6c42\u6240\u6709\u975e\u96f6\u6570\u503c\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4fdd\u6301\u4e0d\u53d8\uff0c\u56e0\u6b64\u4e0d\u80fd\u7b80\u5355\u4ea4\u6362\u5de6\u53f3\u6307\u9488\u6307\u5411\u7684\u6570\u5b57\uff0c\u5fc5\u987b\u8fdb\u884c\u6574\u4f53\u7684\u632a\u52a8\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n^2)\u3002</p> <p><code>moveZeroes2</code>\u65b9\u6cd5\u4e2d\uff0c\u5de6\u4fa7\u6307\u9488\u7ef4\u62a4\u975e\u96f6\u533a\uff0c\u4ea4\u6362\u64cd\u4f5c\u53ef\u4ee5\u7ef4\u6301\u6240\u6709\u975e\u96f6\u6570\u503c\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4fdd\u6301\u4e0d\u53d8\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n)\u3002</p>"},{"location":"hot100/doublePointers/LC42/","title":"LC42 - \u63a5\u96e8\u6c34","text":"TrappingRainWater.go<pre><code>package DoublePointers\n\nfunc trap(height []int) int {\n    return trap1(height)\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc trap1(height []int) int {\n    size := len(height)\n    lmax := make([]int, size)\n    lmax[0] = height[0]\n    for i := 1; i &lt; size; i++ {\n        lmax[i] = max(lmax[i-1], height[i])\n    }\n    rmax := make([]int, size)\n    rmax[size-1] = height[size-1]\n    for j := size - 2; j &gt;= 0; j-- {\n        rmax[j] = max(rmax[j+1], height[j])\n    }\n    result := 0\n    for i := 1; i &lt; size-1; i++ {\n        limit := min(lmax[i-1], rmax[i+1])\n        curVolume := max(0, limit-height[i])\n        result += curVolume\n    }\n    return result\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc trap2(height []int) int {\n    left, right := 1, len(height)-2\n    lmax, rmax := height[0], height[len(height)-1]\n    result := 0\n    for left &lt;= right {\n        if lmax &lt;= rmax {\n            result += max(0, lmax-height[left])\n            lmax = max(lmax, height[left])\n            left++\n        } else {\n            result += max(0, rmax-height[right])\n            rmax = max(rmax, height[right])\n            right--\n        }\n    }\n    return result\n}\n</code></pre> <p>\u6bcf\u4e2a\u683c\u5b50\u7684\u6c34\u4f4d\u7ebf\u53d6\u51b3\u4e8e\u5de6\u4fa7\u6700\u5927\u9ad8\u5ea6\u548c\u53f3\u4fa7\u6700\u5927\u9ad8\u5ea6\u7684\u8f83\u5c0f\u503c\u3002</p>"},{"location":"hot100/hashTable/LC1/","title":"LC1 - \u4e24\u6570\u4e4b\u548c","text":"TwoSum.go<pre><code>package HashTable\n\nimport (\n    \"cmp\"\n    \"slices\"\n)\n\nfunc twoSum(nums []int, target int) []int {\n    return twoSum1(nums, target)\n}\n\ntype indexedNum struct {\n    Value int\n    Index int\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * log n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc twoSum1(nums []int, target int) []int {\n    indexedNums := make([]indexedNum, len(nums))\n    for i, num := range nums {\n        indexedNums[i] = indexedNum{num, i}\n    }\n    slices.SortFunc(indexedNums, func(a, b indexedNum) int {\n        return cmp.Compare(a.Value, b.Value)\n    })\n    left, right := 0, len(nums)-1\n    for left &lt; right {\n        sum := indexedNums[left].Value + indexedNums[right].Value\n        if sum == target {\n            return []int{indexedNums[left].Index, indexedNums[right].Index}\n        } else if sum &gt; target {\n            right--\n        } else {\n            left++\n        }\n    }\n    return nil\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc twoSum2(nums []int, target int) []int {\n    hashTable := make(map[int]int)\n    for index2, num2 := range nums {\n        num1 := target - num2\n        if index1, ok := hashTable[num1]; ok {\n            return []int{index1, index2}\n        } else {\n            hashTable[num2] = index2\n        }\n    }\n    return nil\n}\n</code></pre> <p>\u7b2c\u4e00\u53cd\u5e94\u662f\u6392\u5e8f\u540e\u53cc\u6307\u9488\uff0c\u4f46\u7531\u4e8e\u9700\u8981\u8fd4\u56de\u539f\u6570\u7ec4\u7d22\u5f15\u800c\u975e\u6570\u503c\uff0c\u56e0\u6b64\u5fc5\u987b\u501f\u52a9\u8f85\u52a9\u6570\u7ec4\u3002</p>"},{"location":"hot100/hashTable/LC128/","title":"LC128 - \u6700\u957f\u8fde\u7eed\u5e8f\u5217","text":"LongestConsecutiveSequence.go<pre><code>package HashTable\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc longestConsecutive(nums []int) int {\n    hashSet := make(map[int]bool)\n    for _, num := range nums {\n        hashSet[num] = true\n    }\n    result := 0\n    for num := range hashSet {\n        if hashSet[num-1] {\n            continue\n        }\n        tmp := num\n        for hashSet[tmp] {\n            tmp++\n        }\n        result = max(result, tmp-num)\n    }\n    return result\n}\n</code></pre> <p>\u6700\u5173\u952e\u7684\u90e8\u5206\u5c31\u662f11-13\u884c\uff0c\u6b63\u662f\u6709\u4e86\u8fd9\u91cc\u7684\u526a\u679d\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u624d\u5f97\u4ee5\u63a7\u5236\u5728O(n)\u3002</p> <p>\u9664\u6b64\u4ee5\u5916\u5fc5\u987b\u904d\u5386\u54c8\u5e0c\u8868\u800c\u975e\u539f\u59cb\u6570\u7ec4\uff0c\u56e0\u4e3a\u539f\u59cb\u6570\u636e\u4e2d\u53ef\u80fd\u5b58\u5728\u91cd\u590d\u6570\u5b57\uff0c\u5728\u7279\u5b9a\u60c5\u51b5\u4e0b(\u5982: 1111...2345...)\u4f1a\u4f7f\u65f6\u95f4\u590d\u6742\u5ea6\u8fbe\u5230O(n^2)\u89c4\u6a21\u3002</p>"},{"location":"hot100/hashTable/LC49/","title":"LC49 - \u5b57\u6bcd\u5f02\u4f4d\u8bcd\u5206\u7ec4","text":"GroupAnagrams.go<pre><code>package HashTable\n\nimport \"slices\"\n\nfunc groupAnagrams(strs []string) [][]string {\n    hashTable := make(map[string][]string)\n    for _, str := range strs {\n        strByte := []byte(str)\n        slices.Sort(strByte)\n        s := string(strByte)\n        hashTable[s] = append(hashTable[s], str)\n    }\n    result := make([][]string, 0)\n    for _, group := range hashTable {\n        result = append(result, group)\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/linkedList/LC138/","title":"LC138 - \u968f\u673a\u94fe\u8868\u7684\u590d\u5236","text":"CopyListWithRandomPointer.go<pre><code>package LinkedList\n\ntype Node struct {\n    Val    int\n    Next   *Node\n    Random *Node\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc copyRandomList(head *Node) *Node {\n    if head == nil {\n        return nil\n    }\n    for cur := head; cur != nil; cur = cur.Next.Next {\n        copyNode := new(Node)\n        copyNode.Val = cur.Val\n        copyNode.Next = cur.Next\n        cur.Next = copyNode\n    }\n    for cur := head; cur != nil; cur = cur.Next.Next {\n        copyNode := cur.Next\n        if cur.Random != nil {\n            copyNode.Random = cur.Random.Next\n        } else {\n            copyNode.Random = nil\n        }\n    }\n    copyHead := head.Next\n    for cur := head; cur != nil; cur = cur.Next {\n        copyNode := cur.Next\n        cur.Next = copyNode.Next\n        if copyNode.Next != nil {\n            copyNode.Next = copyNode.Next.Next\n        } else {\n            copyNode.Next = nil\n        }\n    }\n    return copyHead\n}\n</code></pre>"},{"location":"hot100/linkedList/LC141/","title":"LC141 - \u73af\u5f62\u94fe\u8868","text":"LinkedListCycle.go<pre><code>package LinkedList\n\nfunc hasCycle(head *ListNode) bool {\n    slow, fast := head, head\n    for fast != nil &amp;&amp; fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            return true\n        }\n    }\n    return false\n}\n</code></pre> <p>\u5feb\u6162\u6307\u9488\u3002\u82e5\u94fe\u8868\u6709\u73af\uff0c\u5219\u5feb\u6162\u6307\u9488\u5fc5\u7136\u4f1a\u5728\u73af\u4e0a\u91cd\u65b0\u76f8\u9047\uff1b\u5426\u5219\u5fc5\u7136\u4e0d\u4f1a\u91cd\u65b0\u76f8\u9047\u3002</p>"},{"location":"hot100/linkedList/LC142/","title":"LC142 - \u73af\u5f62\u94fe\u8868II","text":"LinkedListCycle.go<pre><code>func detectCycle(head *ListNode) *ListNode {\n    slow, fast := head, head\n    for fast != nil &amp;&amp; fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            break\n        }\n    }\n    if fast == nil || fast.Next == nil {\n        return nil\n    }\n    fast = head\n    for {\n        if slow == fast {\n            return slow\n        }\n        slow = slow.Next\n        fast = fast.Next\n    }\n}\n</code></pre> <p>\u5feb\u6162\u6307\u9488\u3002\u82e5\u94fe\u8868\u6709\u73af\uff0c\u5219\u5feb\u6162\u6307\u9488\u5fc5\u7136\u4f1a\u5728\u73af\u4e0a\u91cd\u65b0\u76f8\u9047\uff0c\u6b64\u65f6\u5c06\u5feb\u6307\u9488\u91cd\u65b0\u5f52\u4f4d\u81f3\u5934\u8282\u70b9\uff0c\u5feb\u6162\u6307\u9488\u6bcf\u6b21\u8d70\u4e00\u6b65\uff0c\u76f8\u9047\u4f4d\u7f6e\u5373\u4e3a\u5165\u73af\u8282\u70b9\u3002</p>"},{"location":"hot100/linkedList/LC148/","title":"LC148 - \u6392\u5e8f\u94fe\u8868","text":"SortList.go<pre><code>package LinkedList\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * log n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(log n)\nfunc sortList(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    slow, fast := head, head\n    for fast.Next != nil &amp;&amp; fast.Next.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    fast = slow.Next\n    slow.Next = nil\n    head1 := sortList(head)\n    head2 := sortList(fast)\n    newHead := mergeTwoLists(head1, head2)\n    return newHead\n}\n</code></pre> <p><code>mergeTwoLists</code>\u51fd\u6570\u5728LC21\u4e2d\u5b9e\u73b0\u3002</p> <p>\u5f52\u5e76\u6392\u5e8f\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a\u9012\u5f52\u6df1\u5ea6O(log n)\u3002</p>"},{"location":"hot100/linkedList/LC160/","title":"LC160 - \u76f8\u4ea4\u94fe\u8868","text":"IntersectionOfTwoLinkedLists.go<pre><code>package LinkedList\n\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    curA, curB := headA, headB\n    lenA, lenB := 0, 0\n    for ; curA != nil; curA = curA.Next {\n        lenA++\n    }\n    for ; curB != nil; curB = curB.Next {\n        lenB++\n    }\n    curA, curB = headA, headB\n    if lenA &gt; lenB {\n        for i := 0; i &lt; lenA-lenB; i++ {\n            curA = curA.Next\n        }\n    } else {\n        for i := 0; i &lt; lenB-lenA; i++ {\n            curB = curB.Next\n        }\n    }\n    for curA != curB {\n        curA = curA.Next\n        curB = curB.Next\n    }\n    return curA\n}\n</code></pre>"},{"location":"hot100/linkedList/LC19/","title":"LC19 - \u5220\u9664\u94fe\u8868\u7684\u5012\u6570\u7b2cN\u4e2a\u8282\u70b9","text":"RemoveNthNodeFromEndOfList.go<pre><code>package LinkedList\n\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    slow, fast := head, head\n    for i := 0; i &lt; n; i++ {\n        fast = fast.Next\n    }\n    if fast == nil {\n        head = head.Next\n        return head\n    }\n    for fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next\n    }\n    slow.Next = slow.Next.Next\n    return head\n}\n</code></pre>"},{"location":"hot100/linkedList/LC2/","title":"LC2 - \u4e24\u6570\u76f8\u52a0","text":"AddTwoNumbers.go<pre><code>package LinkedList\n\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    carry := 0\n    for l1 != nil || l2 != nil {\n        if l1 == nil {\n            l1 = new(ListNode)\n        }\n        if l2 == nil {\n            l2 = new(ListNode)\n        }\n        sum := (l1.Val + l2.Val + carry) % 10\n        tail.Next = new(ListNode)\n        tail = tail.Next\n        tail.Val = sum\n        carry = (l1.Val + l2.Val + carry) / 10\n        l1 = l1.Next\n        l2 = l2.Next\n    }\n    if carry == 1 {\n        tail.Next = new(ListNode)\n        tail = tail.Next\n        tail.Val = 1\n    }\n    return virtualHead.Next\n}\n</code></pre> <p>\u901a\u8fc7\u521b\u5efa\u865a\u62df\u8282\u70b9\uff0c\u6a21\u62df\u4f4d\u6570\u4e0d\u8db3\u65f6\u7684\u9ad8\u4f4d\u8865\u96f6\u3002</p>"},{"location":"hot100/linkedList/LC206/","title":"LC206 - \u53cd\u8f6c\u94fe\u8868","text":"ReverseLinkedList.go<pre><code>package LinkedList\n\nfunc reverseList(head *ListNode) *ListNode {\n    if head == nil {\n        return head\n    }\n    virtualHead := new(ListNode)\n    virtualHead.Next = head\n    prev, cur, next := virtualHead, head, head.Next\n    for cur != nil {\n        next = cur.Next\n        cur.Next = prev\n        prev = cur\n        cur = next\n    }\n    head.Next = nil\n    return prev\n}\n</code></pre>"},{"location":"hot100/linkedList/LC21/","title":"LC21 - \u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u94fe\u8868","text":"MergeTwoSortedLists.go<pre><code>package LinkedList\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    cur1, cur2 := list1, list2\n    for cur1 != nil &amp;&amp; cur2 != nil {\n        if cur1.Val &lt;= cur2.Val {\n            tail.Next = cur1\n            tail = tail.Next\n            cur1 = cur1.Next\n        } else {\n            tail.Next = cur2\n            tail = tail.Next\n            cur2 = cur2.Next\n        }\n    }\n    for cur1 != nil {\n        tail.Next = cur1\n        tail = tail.Next\n        cur1 = cur1.Next\n    }\n    for cur2 != nil {\n        tail.Next = cur2\n        tail = tail.Next\n        cur2 = cur2.Next\n    }\n    return virtualHead.Next\n}\n</code></pre>"},{"location":"hot100/linkedList/LC234/","title":"LC234 - \u56de\u6587\u94fe\u8868","text":"PalindromeLinkedList.go<pre><code>package LinkedList\n\nfunc isPalindrome(head *ListNode) bool {\n    if head == nil || head.Next == nil {\n        return true\n    }\n    // (1) \u5feb\u6162\u6307\u9488\u5bfb\u627e\u94fe\u8868\u4e2d\u70b9\n    slow, fast := head, head\n    for fast.Next != nil &amp;&amp; fast.Next.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    if fast.Next != nil {\n        fast = fast.Next\n    }\n    // (2) \u53cd\u8f6c\u540e\u9762\u7684\u94fe\u8868\n    reverseList(slow)\n    // (3) \u904d\u5386\u4e24\u4e2a\u94fe\u8868\u9010\u4e2a\u8282\u70b9\u6bd4\u8f83\n    ptr1, ptr2 := head, fast\n    for ptr1 != nil &amp;&amp; ptr2 != nil &amp;&amp; ptr1.Val == ptr2.Val {\n        ptr1 = ptr1.Next\n        ptr2 = ptr2.Next\n    }\n    var result bool\n    if ptr1 == nil || ptr2 == nil {\n        result = true\n    } else {\n        result = false\n    }\n    // (4) \u53cd\u8f6c\u56de\u540e\u9762\u7684\u94fe\u8868\n    reverseList(fast)\n    return result\n}\n</code></pre> <p><code>reverseList</code>\u51fd\u6570\u5728LC206\u4e2d\u5b9e\u73b0\u3002</p> <p>\u6b64\u5904\u4e4b\u6240\u4ee5\u9009\u62e9\u53cd\u8f6c\u540e\u9762\u7684\u94fe\u8868\u800c\u975e\u524d\u9762\u7684\u94fe\u8868\uff0c\u662f\u4e3a\u4e86\u9632\u6b62\u51fa\u73b0\u94fe\u8868\u65ad\u5f00\uff0c\u4ece\u800c\u7b80\u5316\u7f16\u7801\u96be\u5ea6\u3002</p>"},{"location":"hot100/linkedList/LC24/","title":"LC24 - \u4e24\u4e24\u4ea4\u6362\u94fe\u8868\u4e2d\u7684\u8282\u70b9","text":"SwapNodesInPairs.go<pre><code>package LinkedList\n\nfunc swapPairs(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    tail.Next = head\n    slow, fast := head, head.Next\n    for {\n        slow.Next = fast.Next\n        fast.Next = slow\n        tail.Next = fast\n        slow, fast = fast, slow\n        if fast.Next == nil || fast.Next.Next == nil {\n            break\n        }\n        tail = fast\n        slow = slow.Next.Next\n        fast = fast.Next.Next\n    }\n    return virtualHead.Next\n}\n</code></pre>"},{"location":"hot100/linkedList/LC25/","title":"LC25 - K\u4e2a\u4e00\u7ec4\u7ffb\u8f6c\u94fe\u8868","text":"ReverseNodesInKGroup.go<pre><code>package LinkedList\n\n// reverseSubLinkedList: \u53cd\u8f6c\u4ee5preStart.Next\u4e3a\u5f00\u59cb\u4f4d\u7f6e\u3001end\u4e3a\u7ed3\u675f\u4f4d\u7f6e\u7684\u5b50\u94fe\n// \u5305\u62ec\u5185\u90e8\u94fe\u8868\u7684\u53cd\u8f6c\uff0c\u4ee5\u53ca\u5916\u90e8\u94fe\u8868\u7684\u8fde\u63a5\nfunc reverseSubLinkedList(preStart, end *ListNode) {\n    endNext := end.Next\n    if preStart.Next == end {\n        return\n    }\n    cur := preStart.Next\n    var prev, next *ListNode\n    for cur != endNext {\n        next = cur.Next\n        cur.Next = prev\n        prev = cur\n        cur = next\n    }\n    preStart.Next.Next = endNext\n    preStart.Next = end\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    virtualHead := new(ListNode)\n    virtualHead.Next = head\n    preStart, end := virtualHead, virtualHead\n    for i := 0; i &lt; k; i++ {\n        end = end.Next\n    }\n    for {\n        reverseSubLinkedList(preStart, end)\n        for i := 0; i &lt; k; i++ {\n            preStart = preStart.Next\n        }\n        end = preStart\n        for i := 0; i &lt; k; i++ {\n            end = end.Next\n            if end == nil {\n                return virtualHead.Next\n            }\n        }\n    }\n}\n</code></pre> <p>\u672c\u9898\u975e\u5e38\u9002\u5408\u953b\u70bc\u94fe\u8868\u76f8\u5173\u7684\u7f16\u7801\u80fd\u529b\u3002</p>"},{"location":"hot100/matrix/LC240/","title":"LC240 - \u641c\u7d22\u4e8c\u7ef4\u77e9\u9635II","text":"SearchA2DMatrixII.go<pre><code>package Matrix\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n + m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc searchMatrix(matrix [][]int, target int) bool {\n    n, m := len(matrix), len(matrix[0])\n    if target &lt; matrix[0][0] || target &gt; matrix[n-1][m-1] {\n        return false\n    }\n    curX, curY := n-1, 0\n    for curX &gt;= 0 &amp;&amp; curX &lt; n &amp;&amp; curY &gt;= 0 &amp;&amp; curY &lt; m {\n        if matrix[curX][curY] &lt; target {\n            curY++\n        } else if matrix[curX][curY] &gt; target {\n            curX--\n        } else {\n            return true\n        }\n    }\n    return false\n}\n</code></pre> <p>\u53d6\u77e9\u9635\u5de6\u4e0b\u89d2\u5143\u7d20\u4e3a\u8d77\u59cb\u53c2\u8003\u70b9cur\uff0ccur &gt; target\u5219\u53ef\u4ee5\u5220\u9664cur\u6240\u5728\u884c\uff0ccur &lt; target\u5219\u53ef\u4ee5\u5220\u9664cur\u6240\u5728\u5217\u3002</p>"},{"location":"hot100/matrix/LC48/","title":"LC48 - \u65cb\u8f6c\u56fe\u50cf","text":"RotateImage.go<pre><code>package Matrix\n\nfunc rotate(matrix [][]int) {\n    n := len(matrix)\n    downHalf, upHalf := n/2, (n+1)/2\n    for i := 0; i &lt; downHalf; i++ {\n        for j := 0; j &lt; upHalf; j++ {\n            temp := matrix[i][j]\n            matrix[i][j] = matrix[n-1-j][i]\n            matrix[n-1-j][i] = matrix[n-1-i][n-1-j]\n            matrix[n-1-i][n-1-j] = matrix[j][n-1-i]\n            matrix[j][n-1-i] = temp\n        }\n    }\n}\n</code></pre> <p>\u6ce8\u610f\u4e24\u70b9: 1. \u5750\u6807\u53d8\u6362 2. \u77e9\u9635\u5206\u5757</p>"},{"location":"hot100/matrix/LC54/","title":"LC54 - \u87ba\u65cb\u77e9\u9635","text":"SpiralMatrix.go<pre><code>package Matrix\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n * m)\nfunc spiralOrder(matrix [][]int) []int {\n    n, m := len(matrix), len(matrix[0])\n    visited := make([][]bool, n)\n    for i := 0; i &lt; n; i++ {\n        visited[i] = make([]bool, m)\n    }\n    move := [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n    curX, curY, curMove := 0, 0, 0\n    result := make([]int, 0)\n    for k := 0; k &lt; n*m; k++ {\n        result = append(result, matrix[curX][curY])\n        visited[curX][curY] = true\n        nextX := curX + move[curMove][0]\n        nextY := curY + move[curMove][1]\n        if nextX &gt;= 0 &amp;&amp; nextX &lt; n &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; m &amp;&amp; !visited[nextX][nextY] {\n            curX, curY = nextX, nextY\n        } else {\n            curMove = (curMove + 1) % 4\n            nextX = curX + move[curMove][0]\n            nextY = curY + move[curMove][1]\n            curX, curY = nextX, nextY\n        }\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/matrix/LC73/","title":"LC73 - \u77e9\u9635\u7f6e\u96f6","text":"SetMatrixZeroes.go<pre><code>package Matrix\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc setZeroes(matrix [][]int) {\n    n, m := len(matrix), len(matrix[0])\n    // firstRow: \u7b2c\u4e00\u884c\u662f\u5426\u88ab\u5237\u62100, firstCol: \u7b2c\u4e00\u5217\u662f\u5426\u88ab\u5237\u6210\u96f6, intersection: matrix[0][0]\u662f\u5426\u4e3a0\n    firstRow, firstCol, intersection := false, false, false\n    // (1) \u904d\u5386\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\uff0c\u521d\u59cb\u5316\u4e0a\u8ff0\u4e09\u4e2a\u6807\u8bb0\n    for i := 0; i &lt; m; i++ {\n        if matrix[0][i] == 0 {\n            firstRow = true\n        }\n    }\n    for i := 0; i &lt; n; i++ {\n        if matrix[i][0] == 0 {\n            firstCol = true\n        }\n    }\n    intersection = firstRow || firstCol\n    // (2) \u904d\u5386\u53f3\u4e0b\u89d2\u77e9\u9635\uff0c\u66f4\u65b0\u884c\u5217\u4ee3\u8868\u5143\u7d20\n    for i := 1; i &lt; n; i++ {\n        for j := 1; j &lt; m; j++ {\n            if matrix[i][j] == 0 {\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n            }\n        }\n    }\n    // (3) \u4f9d\u636e\u884c\u5217\u4ee3\u8868\u5143\u7d20\u7684\u503c\uff0c\u5237\u65b0\u53f3\u4e0b\u89d2\u77e9\u9635\n    for i := 1; i &lt; n; i++ {\n        for j := 1; j &lt; m; j++ {\n            if matrix[i][0] == 0 || matrix[0][j] == 0 {\n                matrix[i][j] = 0\n            }\n        }\n    }\n    // (4) \u4f9d\u636e\u4e0a\u8ff0\u4e09\u4e2a\u6807\u8bb0\uff0c\u5237\u65b0\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\n    if intersection {\n        matrix[0][0] = 0\n    }\n    if firstRow {\n        for i := 0; i &lt; m; i++ {\n            matrix[0][i] = 0\n        }\n    }\n    if firstCol {\n        for i := 0; i &lt; n; i++ {\n            matrix[i][0] = 0\n        }\n    }\n}\n</code></pre> <p>\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230\u7684\u662f\u7a7a\u95f4\u590d\u6742\u5ea6O(n + m)\u7684\u7b97\u6cd5\uff0c\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u884c\u6807\u8bb0\u6570\u7ec4\u548c\u5217\u6807\u8bb0\u6570\u7ec4\u3002\u800c\u4e0a\u8ff0\u7a7a\u95f4\u590d\u6742\u5ea6O(1)\u7684\u7b97\u6cd5\u5c31\u662f\u5c06\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u4f5c\u4e3a\u4e86\u5217\u6807\u8bb0\u6570\u7ec4\u548c\u884c\u6807\u8bb0\u6570\u7ec4\uff0c\u5177\u4f53\u8fc7\u7a0b\u89c1\u6ce8\u91ca\u3002</p>"},{"location":"hot100/slidingWindow/LC3/","title":"LC3 - \u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32","text":"LongestSubstringWithoutRepeatingCharacters.go<pre><code>package SlidingWindow\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(\u2223\u03a3\u2223) [\u2223\u03a3\u2223\u4e3a\u5b57\u7b26\u96c6\u5927\u5c0f]\nfunc lengthOfLongestSubstring(s string) int {\n    hashSet := make(map[byte]bool)\n    lbound, rbound, result := 0, 0, 0\n    for ; rbound &lt; len(s); rbound++ {\n        if !hashSet[s[rbound]] {\n            hashSet[s[rbound]] = true\n        } else {\n            result = max(result, rbound-lbound)\n            for ; s[lbound] != s[rbound]; lbound++ {\n                hashSet[s[lbound]] = false\n            }\n            lbound++\n        }\n    }\n    result = max(result, rbound-lbound)\n    return result\n}\n</code></pre>"},{"location":"hot100/slidingWindow/LC438/","title":"LC438 - \u627e\u51fa\u5b57\u7b26\u4e32\u4e2d\u6240\u6709\u5b57\u6bcd\u5f02\u4f4d\u8bcd","text":"FindAllAnagramsInAString.go<pre><code>package SlidingWindow\n\nfunc findAnagrams(s string, p string) []int {\n    ns, np := len(s), len(p)\n    if ns &lt; np {\n        return []int{}\n    }\n    result := []int{}\n    var pCount, sCount [26]int\n    for i := 0; i &lt; np; i++ {\n        pCount[p[i]-'a']++\n        sCount[s[i]-'a']++\n    }\n    if pCount == sCount {\n        result = append(result, 0)\n    }\n    for i := np; i &lt; ns; i++ {\n        sCount[s[i]-'a']++\n        sCount[s[i-np]-'a']--\n        if pCount == sCount {\n            result = append(result, i-np+1)\n        }\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/substring/LC239/","title":"LC239 - \u6ed1\u52a8\u7a97\u53e3\u6700\u5927\u503c","text":"SlidingWindowMaxium.go<pre><code>package Substring\n\nimport \"container/list\"\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(k)\nfunc maxSlidingWindow(nums []int, k int) []int {\n    result := make([]int, 0)\n    l := list.New()\n    for i := 0; i &lt; k; i++ {\n        for l.Len() &gt; 0 &amp;&amp; nums[i] &gt;= nums[l.Back().Value.(int)] {\n            l.Remove(l.Back())\n        }\n        l.PushBack(i)\n    }\n    result = append(result, nums[l.Front().Value.(int)])\n    for i := k; i &lt; len(nums); i++ {\n        if l.Front().Value.(int) == i-k {\n            l.Remove(l.Front())\n        }\n        for l.Len() &gt; 0 &amp;&amp; nums[i] &gt;= nums[l.Back().Value.(int)] {\n            l.Remove(l.Back())\n        }\n        l.PushBack(i)\n        result = append(result, nums[l.Front().Value.(int)])\n    }\n    return result\n}\n</code></pre> <p>\u5355\u8c03\u961f\u5217</p>"},{"location":"hot100/substring/LC560/","title":"LC560 - \u548c\u4e3aK\u7684\u5b50\u6570\u7ec4","text":"SubarraySumEqualsK.go<pre><code>package Substring\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc subarraySum(nums []int, k int) int {\n    nums = append([]int{0}, nums...)\n    prefixSum := make([]int, len(nums))\n    for i := 1; i &lt; len(nums); i++ {\n        prefixSum[i] = prefixSum[i-1] + nums[i]\n    }\n    // nums[i...j]\u7d2f\u52a0\u548c = prefixSum[j] - prefixSum[i - 1]\n    hashMap := make(map[int]int)\n    hashMap[0] = 1\n    result := 0\n    for i := 1; i &lt; len(nums); i++ {\n        result += hashMap[prefixSum[i]-k]\n        hashMap[prefixSum[i]]++\n    }\n    return result\n}\n</code></pre> <p>\u524d\u7f00\u548c+\u4e24\u6570\u4e4b\u548c</p>"},{"location":"hot100/substring/LC76/","title":"LC76 - \u6700\u5c0f\u8986\u76d6\u5b50\u4e32","text":"MinimumWindowSubstring.go<pre><code>package Substring\n\nimport \"math\"\n\nfunc minWindow(s string, t string) string {\n    hashMap := make(map[byte]int)\n    debt := 0\n    for i := 0; i &lt; len(t); i++ {\n        hashMap[t[i]]--\n        debt++\n    }\n    minLen := math.MaxInt\n    minPos := 0\n    for lbound, rbound := 0, 0; rbound &lt; len(s); rbound++ {\n        if hashMap[s[rbound]] &lt; 0 {\n            debt--\n        }\n        hashMap[s[rbound]]++\n        if debt == 0 {\n            for ; hashMap[s[lbound]] &gt; 0; lbound++ {\n                hashMap[s[lbound]]--\n            }\n            if rbound-lbound+1 &lt; minLen {\n                minLen = rbound - lbound + 1\n                minPos = lbound\n            }\n        }\n    }\n    if minLen == math.MaxInt {\n        return \"\"\n    }\n    return s[minPos : minPos+minLen]\n}\n</code></pre> <p>debt\u53d8\u91cf\u8bb0\u5f55\u603b\u503a\u52a1\uff0chashMap\u8bb0\u5f55\u5177\u4f53\u7684\u503a\u52a1\u8868\u3002\u7b2c\u4e00\u9636\u6bb5\u6ed1\u52a8\u7a97\u53e3\u4e0d\u65ad\u6269\u5927\uff0c\u76f4\u81f3\u603b\u503a\u52a1\u51cf\u5c0f\u4e3a0\u3002\u7b2c\u4e8c\u9636\u6bb5\u6ed1\u52a8\u7a97\u53e3\u6bcf\u6b21\u6269\u5927\u4e00\u683c(\u53f3\u8fb9\u754c\u5411\u53f3\u79fb\u52a8)\uff0c\u968f\u540e\u5c1d\u8bd5\u7f29\u5c0f(\u5de6\u8fb9\u754c\u5411\u53f3\u79fb\u52a8)\u3002</p>"}]}