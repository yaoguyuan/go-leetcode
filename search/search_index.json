{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Welcome to go-leetcode","text":"<p>A site for leetcoder with golang</p>"},{"location":"hot100/array/LC189/","title":"LC189 - \u8f6e\u8f6c\u6570\u7ec4","text":"RotateArray.go<pre><code>package Array\n\nfunc rotate(nums []int, k int) {\n    size := len(nums)\n    k = k % size\n    reverse(nums, 0, size-1)\n    reverse(nums, 0, k-1)\n    reverse(nums, k, size-1)\n}\n\nfunc reverse(nums []int, start, end int) {\n    for i, j := start, end; i &lt; j; i, j = i+1, j-1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n}\n</code></pre> <p>\u6ce8\u610f\u9700\u8981\u5148\u5bf9 k \u53d6\u6a21</p>"},{"location":"hot100/array/LC238/","title":"LC238 - \u9664\u81ea\u8eab\u5916\u6570\u7ec4\u7684\u4e58\u79ef","text":"ProductOfArrayExceptSelf.go<pre><code>package Array\n\nfunc productExceptSelf(nums []int) []int {\n    prefixSum, suffixSum := make([]int, len(nums)), make([]int, len(nums))\n    prefixSum[0], suffixSum[len(nums)-1] = nums[0], nums[len(nums)-1]\n    for i := 1; i &lt; len(nums); i++ {\n        prefixSum[i] = prefixSum[i-1] * nums[i]\n    }\n    for i := len(nums) - 2; i &gt;= 0; i-- {\n        suffixSum[i] = suffixSum[i+1] * nums[i]\n    }\n    result := make([]int, len(nums))\n    for i := 1; i &lt; len(nums)-1; i++ {\n        result[i] = prefixSum[i-1] * suffixSum[i+1]\n    }\n    result[0] = suffixSum[1]\n    result[len(nums)-1] = prefixSum[len(nums)-2]\n    return result\n}\n</code></pre>"},{"location":"hot100/array/LC41/","title":"LC41 - \u7f3a\u5931\u7684\u7b2c\u4e00\u4e2a\u6b63\u6570","text":"FirstMissingPositive.go<pre><code>package Array\n\n// \u53cc\u6307\u9488\u89e3\u6cd5, \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc firstMissingPositive(nums []int) int {\n    size := len(nums)\n    l, r := 0, size\n    // nums[0...l-1] -&gt; 1 2 3 ... l, \u8868\u793a\u5df2\u5f52\u4f4d\u7684\u90e8\u5206\n    // nums[r...size-1] -&gt; \u8868\u793a\u5783\u573e\u533a\uff0c\u540c\u65f6\u8868\u793a\u5728\u6700\u597d\u60c5\u51b5\u4e0b1-r\u8fd9\u4e9b\u6570\u5b57\u53ef\u4ee5\u5168\u90e8\u6536\u96c6\n    for l &lt; r {\n        if nums[l] == l+1 {\n            // (1) \u5df2\u5f52\u4f4d -&gt; \u7ee7\u7eed\u5224\u65ad\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\n            l++\n        } else if nums[l] &lt;= l || nums[l] &gt; r || nums[nums[l]-1] == nums[l] {\n            // (2) \u5df2\u8d8a\u754c\u6216\u76ee\u6807\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u5df2\u5f52\u4f4d -&gt; \u5c06\u5f53\u524d\u6570\u5b57\u5206\u914d\u5230\u5783\u573e\u533a\n            nums[l], nums[r-1] = nums[r-1], nums[l]\n            r--\n        } else {\n            // (3) \u4e00\u822c\u60c5\u51b5 -&gt; \u5c06\u5f53\u524d\u6570\u5b57\u4e0e\u76ee\u6807\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u8fdb\u884c\u4ea4\u6362\n            nums[l], nums[nums[l]-1] = nums[nums[l]-1], nums[l]\n        }\n    }\n    return l + 1\n}\n</code></pre> <p>MEX\u95ee\u9898\uff0c\u6ce8\u91ca\u5df2\u7ecf\u5199\u5f97\u5f88\u6e05\u695a\uff0c\u5f3a\u63a8\u5de6\u795e\u7b97\u6cd5\u8bb2\u89e3</p>"},{"location":"hot100/array/LC53/","title":"LC53 - \u6700\u5927\u5b50\u6570\u7ec4\u548c","text":"MaximumSubarray.go<pre><code>package Array\n\nimport \"math\"\n\nfunc maxSubArray(nums []int) int {\n    nums = append([]int{0}, nums...)\n    prefixSum := make([]int, len(nums))\n    for i := 1; i &lt; len(nums); i++ {\n        prefixSum[i] = prefixSum[i-1] + nums[i]\n    }\n    minPrefixSum := 0\n    maxSum := math.MinInt\n    for i := 1; i &lt; len(nums); i++ {\n        maxSum = max(maxSum, prefixSum[i]-minPrefixSum)\n        minPrefixSum = min(minPrefixSum, prefixSum[i])\n    }\n    return maxSum\n}\n</code></pre> <p>\u524d\u7f00\u548c</p>"},{"location":"hot100/array/LC56/","title":"LC56 - \u5408\u5e76\u533a\u95f4","text":"MergeIntervals.go<pre><code>package Array\n\nimport (\n    \"cmp\"\n    \"slices\"\n)\n\nfunc merge(intervals [][]int) [][]int {\n    slices.SortFunc(intervals, func(a, b []int) int {\n        return cmp.Compare(a[0], b[0])\n    })\n    result := make([][]int, 0)\n    curStart := intervals[0][0]\n    curEnd := intervals[0][1]\n    for i := 0; i &lt; len(intervals); i++ {\n        if curEnd &gt;= intervals[i][0] {\n            curEnd = max(curEnd, intervals[i][1])\n        } else {\n            result = append(result, []int{curStart, curEnd})\n            curStart = intervals[i][0]\n            curEnd = intervals[i][1]\n        }\n    }\n    result = append(result, []int{curStart, curEnd})\n    return result\n}\n</code></pre>"},{"location":"hot100/backtrack/LC131/","title":"LC131 - \u5206\u5272\u56de\u6587\u4e32","text":"PalindromePartitioning.go<pre><code>package Backtrack\n\nfunc partition(s string) [][]string {\n    result := make([][]string, 0)\n    path := make([]string, 0)\n    var f func(int)\n    f = func(index int) {\n        if index == len(s) {\n            tmp := make([]string, len(path))\n            copy(tmp, path)\n            result = append(result, tmp)\n            return\n        }\n        for end := index + 1; end &lt;= len(s); end++ {\n            if isPalindrome(s[index:end]) {\n                path = append(path, s[index:end])\n                f(end)\n                path = path[:len(path)-1]\n            }\n        }\n    }\n    f(0)\n    return result\n}\n\nfunc isPalindrome(s string) bool {\n    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 {\n        if s[i] != s[j] {\n            return false\n        }\n    }\n    return true\n}\n</code></pre>"},{"location":"hot100/backtrack/LC17/","title":"LC17 - \u7535\u8bdd\u53f7\u7801\u7684\u5b57\u6bcd\u7ec4\u5408","text":"LetterCombinations.go<pre><code>package Backtrack\n\nvar hashMap map[int]string\n\nfunc initMap() {\n    hashMap = make(map[int]string)\n    hashMap[2] = \"abc\"\n    hashMap[3] = \"def\"\n    hashMap[4] = \"ghi\"\n    hashMap[5] = \"jkl\"\n    hashMap[6] = \"mno\"\n    hashMap[7] = \"pqrs\"\n    hashMap[8] = \"tuv\"\n    hashMap[9] = \"wxyz\"\n}\n\nfunc letterCombinations(digits string) []string {\n    if digits == \"\" {\n        return nil\n    }\n    initMap()\n    result := make([]string, 0)\n    size := len(digits)\n    var path string\n    var f func(i int)\n    f = func(i int) {\n        if i == size {\n            result = append(result, path)\n            return\n        }\n        curSet := hashMap[int(digits[i]-'0')]\n        for _, ch := range curSet {\n            path += string(ch)\n            f(i + 1)\n            path = path[:len(path)-1]\n        }\n    }\n    f(0)\n    return result\n}\n</code></pre>"},{"location":"hot100/backtrack/LC22/","title":"LC22 - \u62ec\u53f7\u751f\u6210","text":"GenerateParentheses.go<pre><code>package Backtrack\n\nfunc generateParenthesis(n int) []string {\n    result := make([]string, 0)\n    var path string\n    var f func(index, leftP, rightP int)\n    f = func(index, leftP, rightP int) {\n        if index == 2*n {\n            result = append(result, path)\n            return\n        }\n        // (1) \u5de6\u62ec\u53f7\u6570\u91cf\u5c0f\u4e8e N \u65f6, \u53ef\u4ee5\u653e\u5de6\u62ec\u53f7\n        if leftP &lt; n {\n            path = path + string('(')\n            f(index+1, leftP+1, rightP)\n            path = path[:len(path)-1]\n        }\n        // (2) \u53f3\u62ec\u53f7\u6570\u91cf\u5c0f\u4e8e\u5de6\u62ec\u53f7\u65f6, \u53ef\u4ee5\u653e\u53f3\u62ec\u53f7\n        if rightP &lt; leftP {\n            path = path + string(')')\n            f(index+1, leftP, rightP+1)\n            path = path[:len(path)-1]\n        }\n    }\n    f(0, 0, 0)\n    return result\n}\n</code></pre>"},{"location":"hot100/backtrack/LC39/","title":"LC39 - \u7ec4\u5408\u603b\u548c","text":"CombinationSum.go<pre><code>package Backtrack\n\nimport (\n    \"cmp\"\n    \"slices\"\n)\n\nfunc combinationSum(candidates []int, target int) [][]int {\n    slices.SortFunc(candidates, func(a, b int) int {\n        return cmp.Compare(b, a)\n    })\n    size := len(candidates)\n    result := make([][]int, 0)\n    path := make([]int, 0)\n    pathSum := 0\n    var f func(i int)\n    f = func(i int) {\n        if i == size || pathSum &gt; target {\n            return\n        }\n        if pathSum == target {\n            tmp := make([]int, len(path))\n            copy(tmp, path)\n            result = append(result, tmp)\n            return\n        }\n        // (1) \u4e0d\u9009\u62e9\u5f53\u524d\u5143\u7d20\n        f(i + 1)\n        // (2) \u9009\u62e9\u4e00\u4e2a\u5f53\u524d\u5143\u7d20\n        path = append(path, candidates[i])\n        pathSum += candidates[i]\n        f(i)\n        path = path[:len(path)-1]\n        pathSum -= candidates[i]\n    }\n    f(0)\n    return result\n}\n</code></pre>"},{"location":"hot100/backtrack/LC46/","title":"LC46 - \u5168\u6392\u5217","text":"Permutations.go<pre><code>package Backtrack\n\nfunc permute(nums []int) [][]int {\n    result := make([][]int, 0)\n    size := len(nums)\n    var f func(i int)\n    f = func(i int) {\n        if i == size {\n            tmp := make([]int, size)\n            copy(tmp, nums)\n            result = append(result, tmp)\n            return\n        }\n        for j := i; j &lt; size; j++ {\n            nums[i], nums[j] = nums[j], nums[i]\n            f(i + 1)\n            nums[i], nums[j] = nums[j], nums[i]\n        }\n    }\n    f(0)\n    return result\n}\n</code></pre>"},{"location":"hot100/backtrack/LC51/","title":"LC51 - N \u7687\u540e","text":"NQueens.go<pre><code>package Backtrack\n\nimport (\n    \"math\"\n    \"strings\"\n)\n\nfunc solveNQueens(n int) [][]string {\n    result := make([][]string, 0)\n    distribution := make([]int, 0)\n    var f func(int)\n    f = func(index int) {\n        if index == n {\n            curAns := getAns(n, distribution)\n            result = append(result, curAns)\n            return\n        }\n        for curPos := 0; curPos &lt; n; curPos++ {\n            isValid := true\n            for prevIndex, prevPos := range distribution {\n                if curPos == prevPos || diagnol(index, curPos, prevIndex, prevPos) {\n                    isValid = false\n                    break\n                }\n            }\n            if isValid {\n                distribution = append(distribution, curPos)\n                f(index + 1)\n                distribution = distribution[:len(distribution)-1]\n            }\n        }\n    }\n    f(0)\n    return result\n}\n\nfunc diagnol(index1, pos1, index2, pos2 int) bool {\n    return math.Abs(float64(pos1-pos2)) == math.Abs(float64(index1-index2))\n}\n\nfunc getAns(n int, distribution []int) []string {\n    result := make([]string, 0)\n    str := strings.Repeat(\".\", n)\n    for _, pos := range distribution {\n        tmp := []byte(str)\n        tmp[pos] = 'Q'\n        result = append(result, string(tmp))\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/backtrack/LC78/","title":"LC78 - \u5b50\u96c6","text":"Subsets.go<pre><code>package Backtrack\n\nfunc subsets(nums []int) [][]int {\n    result := make([][]int, 0)\n    size := len(nums)\n    path := make([]int, 0)\n    var f func(int)\n    f = func(i int) {\n        if i == size {\n            tmp := make([]int, len(path))\n            copy(tmp, path)\n            result = append(result, tmp)\n            return\n        }\n        f(i + 1)\n        path = append(path, nums[i])\n        f(i + 1)\n        path = path[:len(path)-1]\n    }\n    f(0)\n    return result\n}\n</code></pre>"},{"location":"hot100/backtrack/LC79/","title":"LC79 - \u5355\u8bcd\u641c\u7d22","text":"WordSearch.go<pre><code>package Backtrack\n\nfunc exist(board [][]byte, word string) bool {\n    n, m := len(board), len(board[0])\n    visited := make([][]bool, n)\n    for i := 0; i &lt; n; i++ {\n        visited[i] = make([]bool, m)\n    }\n    move := [5]int{-1, 0, 1, 0, -1}\n    var f func(int, int, int) bool\n    f = func(curX, curY, index int) bool {\n        if index == len(word) {\n            return true\n        }\n        if curX &lt; 0 || curX &gt;= n || curY &lt; 0 || curY &gt;= m || visited[curX][curY] || board[curX][curY] != word[index] {\n            return false\n        }\n        visited[curX][curY] = true\n        for i := 0; i &lt; 4; i++ {\n            if f(curX+move[i], curY+move[i+1], index+1) {\n                visited[curX][curY] = false\n                return true\n            }\n        }\n        visited[curX][curY] = false\n        return false\n    }\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; m; j++ {\n            if f(i, j, 0) {\n                return true\n            }\n        }\n    }\n    return false\n}\n</code></pre>"},{"location":"hot100/binarySearch/LC153/","title":"LC153 - \u5bfb\u627e\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4\u4e2d\u7684\u6700\u5c0f\u503c","text":"FindMinimumInRotatedSortedArray.go<pre><code>package BinarySearch\n\nimport \"math\"\n\nfunc findMin(nums []int) int {\n    ans := math.MaxInt\n    for l, r := 0, len(nums)-1; l &lt;= r; {\n        m := l + (r-l)/2\n        if nums[l] &lt;= nums[m] {\n            ans = min(nums[l], ans)\n            l = m + 1\n        } else {\n            ans = min(nums[m], ans)\n            r = m - 1\n        }\n    }\n    return ans\n}\n</code></pre>"},{"location":"hot100/binarySearch/LC33/","title":"LC33 - \u641c\u7d22\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4","text":"SearchInRotatedSortedArray.go<pre><code>package BinarySearch\n\nfunc search(nums []int, target int) int {\n    for l, r := 0, len(nums)-1; l &lt;= r; {\n        m := l + (r-l)/2\n        if nums[m] == target {\n            return m\n        }\n        if nums[l] &lt;= nums[m] {\n            if nums[l] &lt;= target &amp;&amp; target &lt; nums[m] {\n                r = m - 1\n            } else {\n                l = m + 1\n            }\n        } else {\n            if nums[m] &lt; target &amp;&amp; target &lt;= nums[r] {\n                l = m + 1\n            } else {\n                r = m - 1\n            }\n        }\n    }\n    return -1\n}\n\n// (1) \"\u6709\u5e8f\u6570\u7ec4\" \u5c5e\u4e8e \"\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4\"\n// (2) \u5bf9\u4e8e\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4[l,r]\u4ee5\u53ca\u67d0\u4e2a\u5212\u5206\u70b9m, \u5fc5\u6709[l,m]\u4e0e[m,r]\u5176\u4e00\u662f\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4\uff0c\u5176\u4e8c\u662f\u6709\u5e8f\u6570\u7ec4\n</code></pre> <p>26 - 27\u884c\u7684\u4e24\u4e2a\u7ed3\u8bba\u662f\u7406\u89e3\u65cb\u8f6c\u6392\u5e8f\u6570\u7ec4\u7684\u5173\u5065\uff0cLC153 (\u4e0b\u4e00\u9898) \u4e5f\u4f1a\u7528\u5230\u3002</p>"},{"location":"hot100/binarySearch/LC34/","title":"LC34 - \u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u67e5\u627e\u5143\u7d20\u7684\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e","text":"SearchRange.go<pre><code>package BinarySearch\n\nfunc searchRange(nums []int, target int) []int {\n    if find(nums, target) {\n        return []int{findLeft(nums, target), findRight(nums, target)}\n    } else {\n        return []int{-1, -1}\n    }\n}\n\nfunc find(nums []int, target int) bool {\n    for l, r := 0, len(nums)-1; l &lt;= r; {\n        m := (l + r) / 2\n        if nums[m] == target {\n            return true\n        } else if nums[m] &gt; target {\n            r = m - 1\n        } else {\n            l = m + 1\n        }\n    }\n    return false\n}\n\nfunc findLeft(nums []int, target int) int {\n    ans := len(nums)\n    for l, r := 0, len(nums)-1; l &lt;= r; {\n        m := (l + r) / 2\n        if nums[m] &gt;= target {\n            ans = m\n            r = m - 1\n        } else {\n            l = m + 1\n        }\n    }\n    return ans\n}\n\nfunc findRight(nums []int, target int) int {\n    ans := -1\n    for l, r := 0, len(nums)-1; l &lt;= r; {\n        m := (l + r) / 2\n        if nums[m] &lt;= target {\n            ans = m\n            l = m + 1\n        } else {\n            r = m - 1\n        }\n    }\n    return ans\n}\n</code></pre>"},{"location":"hot100/binarySearch/LC35/","title":"LC35 - \u641c\u7d22\u63d2\u5165\u4f4d\u7f6e","text":"SearchInsertPosition.go<pre><code>package BinarySearch\n\n// searchInsert: \u5bfb\u627e\u5927\u4e8e\u7b49\u4e8e target \u7684\u6700\u5de6\u4f4d\u7f6e, \u4e0d\u5b58\u5728\u5219\u8fd4\u56de\u6570\u7ec4\u957f\u5ea6\nfunc searchInsert(nums []int, target int) int {\n    ans := len(nums)\n    for l, r := 0, len(nums)-1; l &lt;= r; {\n        m := (l + r) / 2\n        if nums[m] &gt;= target {\n            ans = m\n            r = m - 1\n        } else {\n            l = m + 1\n        }\n    }\n    return ans\n}\n</code></pre>"},{"location":"hot100/binarySearch/LC4/","title":"LC4 - \u5bfb\u627e\u4e24\u4e2a\u6b63\u5e8f\u6570\u7ec4\u7684\u4e2d\u4f4d\u6570","text":"MedianOfTwoSortedArrays.go<pre><code>package BinarySearch\n\n// findKSortedArrays is a helper function to find the k-th smallest element in two sorted arrays.\n// k: the k-th element to find\n// nums1: the first sorted array\n// s1: the starting index for nums1\n// nums2: the second sorted array\n// s2: the starting index for nums2\nfunc findKSortedArrays(k int, nums1 []int, s1 int, nums2 []int, s2 int) int {\n    len1 := len(nums1)\n    len2 := len(nums2)\n\n    // If nums1 is exhausted, the k-th element must be in nums2.\n    if s1 == len1 {\n        return nums2[s2+k-1]\n    }\n    // If nums2 is exhausted, the k-th element must be in nums1.\n    if s2 == len2 {\n        return nums1[s1+k-1]\n    }\n    // If k is 1, return the minimum of the current elements in both arrays.\n    if k == 1 {\n        return min(nums1[s1], nums2[s2])\n    }\n\n    half := k / 2\n\n    // newS1 is the next starting index for nums1.\n    // newS2 is the next starting index for nums2.\n    // We take 'half' elements from each array if possible.\n    newS1 := min(len1, s1+half)\n    newS2 := min(len2, s2+half)\n\n    // cnt1 is the number of elements considered from nums1 in this step.\n    // cnt2 is the number of elements considered from nums2 in this step.\n    cnt1 := newS1 - s1\n    cnt2 := newS2 - s2\n\n    // Compare the last elements of the considered parts of nums1 and nums2.\n    if nums1[newS1-1] &lt;= nums2[newS2-1] {\n        return findKSortedArrays(k-cnt1, nums1, newS1, nums2, s2)\n    } else {\n        return findKSortedArrays(k-cnt2, nums1, s1, nums2, newS2)\n    }\n}\n\n// findMedianSortedArrays finds the median of two sorted arrays.\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n    len1 := len(nums1)\n    len2 := len(nums2)\n    lenTotal := len1 + len2\n\n    // For an odd length, the median is the single middle element.\n    // For an even length, the median is the average of the two middle elements.\n    // We can unify these two situations by calculating 'k1' and 'k2' :\n    k1 := (lenTotal + 1) / 2\n    k2 := (lenTotal + 2) / 2\n\n    // Find the k1-th and k2-th smallest elements.\n    r1 := findKSortedArrays(k1, nums1, 0, nums2, 0)\n    r2 := findKSortedArrays(k2, nums1, 0, nums2, 0)\n\n    return float64(r1+r2) / 2\n}\n</code></pre> <p>\u6ce8\u91ca\u5199\u7684\u6bd4\u8f83\u6e05\u695a\uff0c\u8be6\u7ec6\u5206\u6790\u8fc7\u7a0b\u53c2\u8003\u70ed\u95e8\u9898\u89e3\u3002</p>"},{"location":"hot100/binarySearch/LC74/","title":"LC74 - \u641c\u7d22\u4e8c\u7ef4\u77e9\u9635","text":"SearchA2DMatrix.go<pre><code>package BinarySearch\n\nfunc searchMatrix(matrix [][]int, target int) bool {\n    n, m := len(matrix), len(matrix[0])\n    f := func(index int) int {\n        return matrix[index/m][index%m]\n    }\n    for l, r := 0, n*m-1; l &lt;= r; {\n        mid := (l + r) / 2\n        if f(mid) == target {\n            return true\n        } else if f(mid) &gt; target {\n            r = mid - 1\n        } else {\n            l = mid + 1\n        }\n    }\n    return false\n}\n</code></pre> <p>\u4e8c\u7ef4\u5750\u6807\u7ebf\u6027\u5316</p>"},{"location":"hot100/binaryTree/LC101/","title":"LC101 - \u5bf9\u79f0\u4e8c\u53c9\u6811","text":"Symmetric.go<pre><code>package BinaryTree\n\nfunc isSymmetric(root *TreeNode) bool {\n    if root == nil {\n        return true\n    }\n    return isImage(root.Left, root.Right)\n}\n\nfunc isImage(root1, root2 *TreeNode) bool {\n    if root1 == nil &amp;&amp; root2 == nil {\n        return true\n    }\n    if root1 == nil || root2 == nil {\n        return false\n    }\n    return root1.Val == root2.Val &amp;&amp; isImage(root1.Left, root2.Right) &amp;&amp; isImage(root1.Right, root2.Left)\n}\n</code></pre> <p>\u6ce8\u610f\u672c\u9898\u4e0d\u80fd\u4f7f\u7528\u5224\u65ad\u4e2d\u5e8f\u904d\u5386\u548c\u9006\u4e2d\u5e8f\u904d\u5386\u662f\u5426\u76f8\u540c\u8fd9\u79cd\u65b9\u6cd5\u3002\u4f8b\u5982\uff0c[1,2,2,2,null,2] \u8fd9\u9897\u4e8c\u53c9\u6811\u4e24\u79cd\u65b9\u5f0f\u7684\u904d\u5386\u7ed3\u679c\u76f8\u540c\uff0c\u4f46\u5e76\u4e0d\u662f\u5bf9\u79f0\u4e8c\u53c9\u6811\u3002</p>"},{"location":"hot100/binaryTree/LC102/","title":"LC102 - \u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386","text":"LevelOrderTraversal.go.go<pre><code>package BinaryTree\n\ntype TreeNodeQueue []*TreeNode\n\nfunc (q *TreeNodeQueue) Size() int {\n    return len(*q)\n}\n\nfunc (q *TreeNodeQueue) IsEmpty() bool {\n    return len(*q) == 0\n}\n\nfunc (q *TreeNodeQueue) Enqueue(node *TreeNode) {\n    *q = append(*q, node)\n}\n\nfunc (q *TreeNodeQueue) Dequeue() *TreeNode {\n    if q.IsEmpty() {\n        return nil\n    } else {\n        node := (*q)[0]\n        *q = (*q)[1:]\n        return node\n    }\n}\n\nfunc levelOrder(root *TreeNode) [][]int {\n    result := make([][]int, 0)\n    if root == nil {\n        return result\n    }\n    q := new(TreeNodeQueue)\n    q.Enqueue(root)\n    for !q.IsEmpty() {\n        curCollection := make([]int, 0)\n        curLevelSize := q.Size()\n        for i := 0; i &lt; curLevelSize; i++ {\n            cur := q.Dequeue()\n            curCollection = append(curCollection, cur.Val)\n            if cur.Left != nil {\n                q.Enqueue(cur.Left)\n            }\n            if cur.Right != nil {\n                q.Enqueue(cur.Right)\n            }\n        }\n        result = append(result, curCollection)\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC104/","title":"LC104 - \u4e8c\u53c9\u6811\u7684\u6700\u5927\u6df1\u5ea6","text":"MaximumDepth.go<pre><code>package BinaryTree\n\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    leftRet := maxDepth(root.Left)\n    rightRet := maxDepth(root.Right)\n    return 1 + max(leftRet, rightRet)\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC105/","title":"LC105 - \u4ece\u524d\u5e8f\u548c\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\u6784\u9020\u4e8c\u53c9\u6811","text":"ConstructBinaryTree.go<pre><code>package BinaryTree\n\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n    if len(preorder) == 0 {\n        return nil\n    }\n    root := new(TreeNode)\n    root.Val = preorder[0]\n    pos := linearSearch(inorder, root.Val)\n    root.Left = buildTree(preorder[1:pos+1], inorder[:pos])\n    root.Right = buildTree(preorder[pos+1:], inorder[pos+1:])\n    return root\n}\n\nfunc linearSearch(arr []int, val int) int {\n    for i := 0; i &lt; len(arr); i++ {\n        if arr[i] == val {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC108/","title":"LC108 - \u5c06\u6709\u5e8f\u6570\u7ec4\u8f6c\u6362\u4e3a\u4e8c\u53c9\u641c\u7d22\u6811","text":"ConvertSortedArrayToBST.go<pre><code>package BinaryTree\n\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    size := len(nums)\n    if size == 0 {\n        return nil\n    }\n    root := new(TreeNode)\n    root.Val = nums[size/2]\n    root.Left = sortedArrayToBST(nums[:size/2])\n    root.Right = sortedArrayToBST(nums[size/2+1:])\n    return root\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC114/","title":"LC114 - \u4e8c\u53c9\u6811\u5c55\u5f00\u4e3a\u94fe\u8868","text":"FlattenBinaryTreeToLinkedList.go<pre><code>package BinaryTree\n\nfunc flatten(root *TreeNode) {\n    cur := root\n    for cur != nil {\n        leftChild := cur.Left\n        rightChild := cur.Right\n        if leftChild != nil {\n            rightMost := findRightMost(leftChild)\n            cur.Left = nil\n            cur.Right = leftChild\n            rightMost.Right = rightChild\n        }\n        cur = cur.Right\n    }\n}\n\nfunc findRightMost(node *TreeNode) *TreeNode {\n    var pre *TreeNode = nil\n    for node != nil {\n        pre = node\n        if node.Right != nil {\n            node = node.Right\n        } else {\n            node = node.Left\n        }\n    }\n    return pre\n}\n</code></pre> <p>\u5c06\u5de6\u5b50\u6811\u63d2\u5165\u5230\u5f53\u524d\u8282\u70b9\u548c\u53f3\u5b50\u6811\u4e4b\u95f4\uff0c\u540c\u65f6\u53f3\u5b50\u6811\u8fde\u5230\u5de6\u5b50\u6811\u6700\u53f3\u8282\u70b9\u5904\u3002</p>"},{"location":"hot100/binaryTree/LC124/","title":"LC124 - \u4e8c\u53c9\u6811\u4e2d\u7684\u6700\u5927\u8def\u5f84\u548c","text":"MaxmiumPathSum.go<pre><code>package BinaryTree\n\nimport \"math\"\n\ntype maxPathSumRet struct {\n    maxSum, maxSumWithRoot int\n}\n\nfunc maxPathSum(root *TreeNode) int {\n    return maxPathSumFunc(root).maxSum\n}\n\nfunc maxPathSumFunc(node *TreeNode) maxPathSumRet {\n    if node == nil {\n        return maxPathSumRet{\n            maxSumWithRoot: 0,\n            maxSum:         math.MinInt,\n        }\n    }\n    leftRet := maxPathSumFunc(node.Left)\n    rightRet := maxPathSumFunc(node.Right)\n    curMaxSumWithRoot := max(node.Val, node.Val+leftRet.maxSumWithRoot, node.Val+rightRet.maxSumWithRoot)\n    curMaxSum := max(leftRet.maxSum, rightRet.maxSum, curMaxSumWithRoot, node.Val+leftRet.maxSumWithRoot+rightRet.maxSumWithRoot)\n    return maxPathSumRet{\n        maxSumWithRoot: curMaxSumWithRoot,\n        maxSum:         curMaxSum,\n    }\n}\n</code></pre> <p>\u6ce8\u610f\u6811\u578bDP\u9012\u5f52\u51fa\u53e3\u8fd4\u56de\u503c\u7684\u8bbe\u7f6e</p>"},{"location":"hot100/binaryTree/LC199/","title":"LC199 - \u4e8c\u53c9\u6811\u7684\u53f3\u89c6\u56fe","text":"RightSideView.go<pre><code>package BinaryTree\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc rightSideView(root *TreeNode) []int {\n    result := make([]int, 0)\n    if root == nil {\n        return result\n    }\n    q := new(TreeNodeQueue)\n    q.Enqueue(root)\n    for !q.IsEmpty() {\n        curLevelSize := q.Size()\n        for i := 0; i &lt; curLevelSize; i++ {\n            cur := q.Dequeue()\n            if i == 0 {\n                result = append(result, cur.Val)\n            }\n            if cur.Right != nil {\n                q.Enqueue(cur.Right)\n            }\n            if cur.Left != nil {\n                q.Enqueue(cur.Left)\n            }\n        }\n    }\n    return result\n}\n</code></pre> <p>\u548cLC102\u51e0\u4e4e\u6ca1\u6709\u533a\u522b</p>"},{"location":"hot100/binaryTree/LC226/","title":"LC226 - \u7ffb\u8f6c\u4e8c\u53c9\u6811","text":"Invert.go<pre><code>package BinaryTree\n\nfunc invertTree(root *TreeNode) *TreeNode {\n    if root == nil {\n        return root\n    }\n    leftRet := invertTree(root.Left)\n    rightRet := invertTree(root.Right)\n    root.Left, root.Right = rightRet, leftRet\n    return root\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC230/","title":"LC230 - \u4e8c\u53c9\u641c\u7d22\u6811\u4e2d\u7b2cK\u5c0f\u7684\u5143\u7d20","text":"KthSmallestElementInABST.go<pre><code>package BinaryTree\n\ntype BSTWithCnt struct {\n    root *TreeNode\n    cnt  map[*TreeNode]int\n}\n\nfunc (bst *BSTWithCnt) Init(root *TreeNode) {\n    bst.root = root\n    bst.cnt = make(map[*TreeNode]int)\n    bst.count(root)\n}\n\nfunc (bst *BSTWithCnt) count(node *TreeNode) int {\n    if node == nil {\n        return 0\n    }\n    ret := bst.count(node.Left) + bst.count(node.Right) + 1\n    bst.cnt[node] = ret\n    return ret\n}\n\nfunc (bst *BSTWithCnt) Findkth(k int) int {\n    return bst.find(bst.root, k)\n}\n\nfunc (bst *BSTWithCnt) find(node *TreeNode, k int) int {\n    leftCnt := bst.cnt[node.Left]\n    if leftCnt == k-1 {\n        return node.Val\n    } else if leftCnt &lt; k-1 {\n        return bst.find(node.Right, k-leftCnt-1)\n    } else {\n        return bst.find(node.Left, k)\n    }\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(h), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n// h\u8868\u793aBST\u7684\u9ad8\u5ea6, n\u8868\u793aBST\u8282\u70b9\u603b\u6570\nfunc kthSmallest(root *TreeNode, k int) int {\n    bst := new(BSTWithCnt)\n    bst.Init(root)\n    return bst.Findkth(k)\n}\n</code></pre> <p>\u4e2d\u5e8f\u904d\u5386\u7684\u65b9\u6cd5\u5c31\u4e0d\u8bf4\u4e86\uff0c\u5176\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(h + k)\u3002\u5f53\u9700\u8981\u9891\u7e41\u67e5\u627e\u7b2cK\u5c0f\u7684\u5143\u7d20\u65f6\uff0c\u901a\u8fc7\u751f\u6210\u9884\u5904\u7406\u7ed3\u6784<code>BSTWithCnt</code>(\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n))\uff0c\u53ef\u4ee5\u5c06\u6bcf\u6b21\u67e5\u627e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u81f3O(h)\u3002</p>"},{"location":"hot100/binaryTree/LC236/","title":"LC236 - \u4e8c\u53c9\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148","text":"LowestCommonAncestor.go<pre><code>package BinaryTree\n\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    if root == nil || root == p || root == q {\n        return root\n    }\n    leftRet := lowestCommonAncestor(root.Left, p, q)\n    rightRet := lowestCommonAncestor(root.Right, p, q)\n    if leftRet != nil &amp;&amp; rightRet != nil {\n        return root\n    }\n    if leftRet == nil &amp;&amp; rightRet == nil {\n        return nil\n    }\n    if leftRet != nil {\n        return leftRet\n    } else {\n        return rightRet\n    }\n}\n</code></pre> <p>LCA\u95ee\u9898\uff0c\u76f4\u63a5\u8bb0\u6a21\u677f\u3002</p>"},{"location":"hot100/binaryTree/LC437/","title":"LC437 - \u8def\u5f84\u603b\u548c III","text":"PathSumIII.go<pre><code>package BinaryTree\n\nfunc pathSum(root *TreeNode, targetSum int) int {\n    hashMap := make(map[int]int)\n    hashMap[0] = 1\n    cnt := 0\n    var dfs func(*TreeNode, int)\n    dfs = func(node *TreeNode, sum int) {\n        if node == nil {\n            return\n        }\n        sum += node.Val\n        cnt += hashMap[sum-targetSum]\n        hashMap[sum]++\n        dfs(node.Left, sum)\n        dfs(node.Right, sum)\n        hashMap[sum]--\n    }\n    dfs(root, 0)\n    return cnt\n}\n</code></pre> <p>\u6839\u636e\u9898\u76ee\u5bf9\u8def\u5f84\u7684\u5b9a\u4e49\uff0c\u672c\u9898\u5b9e\u8d28\u4e0a\u662f\u6811\u7248\u7684LC560\u3002</p> <p>\u9700\u8981\u7279\u522b\u6ce8\u610f\u7684\u662f\u6b64\u5904\u5fc5\u987b\u5728DFS\u7684\u8fc7\u7a0b\u4e2d\u5bf9\u54c8\u5e0c\u8868\u8fdb\u884c\u56de\u6eaf\u3002</p>"},{"location":"hot100/binaryTree/LC543/","title":"LC543 - \u4e8c\u53c9\u6811\u7684\u76f4\u5f84","text":"Diameter.go<pre><code>package BinaryTree\n\ntype diameterRet struct {\n    height, diameter int\n}\n\nfunc diameterOfBinaryTree(root *TreeNode) int {\n    return diameterFunc(root).diameter\n}\n\nfunc diameterFunc(root *TreeNode) diameterRet {\n    if root == nil {\n        return diameterRet{\n            height:   0,\n            diameter: 0,\n        }\n    }\n    leftRet := diameterFunc(root.Left)\n    rightRet := diameterFunc(root.Right)\n    return diameterRet{\n        height:   max(leftRet.height, rightRet.height) + 1,\n        diameter: max(leftRet.diameter, rightRet.diameter, leftRet.height+rightRet.height),\n    }\n}\n</code></pre> <p>\u6811\u578bDP</p>"},{"location":"hot100/binaryTree/LC94/","title":"LC94 - \u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u904d\u5386","text":"InorderTraversal.go<pre><code>package BinaryTree\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc inorderTraversal(root *TreeNode) []int {\n    return inorderTraversal2(root)\n}\n\n// \u9012\u5f52\u5b9e\u73b0\nfunc inorderTraversal1(root *TreeNode) []int {\n    ret := make([]int, 0)\n    if root == nil {\n        return ret\n    }\n    leftRet := inorderTraversal1(root.Left)\n    rightRet := inorderTraversal1(root.Right)\n    ret = append(ret, leftRet...)\n    ret = append(ret, root.Val)\n    ret = append(ret, rightRet...)\n    return ret\n}\n\ntype TreeNodeStack []*TreeNode\n\nfunc (s *TreeNodeStack) Size() int {\n    return len(*s)\n}\n\nfunc (s *TreeNodeStack) IsEmpty() bool {\n    return len(*s) == 0\n}\n\nfunc (s *TreeNodeStack) Push(node *TreeNode) {\n    *s = append(*s, node)\n}\n\nfunc (s *TreeNodeStack) Pop() *TreeNode {\n    if s.IsEmpty() {\n        return nil\n    } else {\n        node := (*s)[s.Size()-1]\n        *s = (*s)[:s.Size()-1]\n        return node\n    }\n}\n\n// \u8fed\u4ee3\u5b9e\u73b0\nfunc inorderTraversal2(root *TreeNode) []int {\n    ret := make([]int, 0)\n    if root == nil {\n        return ret\n    }\n    s := new(TreeNodeStack)\n    cur := root\n    for cur != nil {\n        s.Push(cur)\n        cur = cur.Left\n    }\n    for !s.IsEmpty() {\n        node := s.Pop()\n        ret = append(ret, node.Val)\n        cur = node.Right\n        for cur != nil {\n            s.Push(cur)\n            cur = cur.Left\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC98/","title":"LC98 - \u9a8c\u8bc1\u4e8c\u53c9\u641c\u7d22\u6811","text":"ValidateBST.go<pre><code>package BinaryTree\n\nimport \"math\"\n\ntype isBSTRet struct {\n    isBST          bool\n    maxVal, minVal int\n}\n\nfunc isValidBST(root *TreeNode) bool {\n    return isBSTFunc(root).isBST\n}\n\nfunc isBSTFunc(root *TreeNode) isBSTRet {\n    if root == nil {\n        return isBSTRet{\n            isBST:  true,\n            maxVal: math.MinInt,\n            minVal: math.MaxInt,\n        }\n    }\n    leftRet := isBSTFunc(root.Left)\n    rightRet := isBSTFunc(root.Right)\n    return isBSTRet{\n        isBST:  leftRet.isBST &amp;&amp; rightRet.isBST &amp;&amp; root.Val &gt; leftRet.maxVal &amp;&amp; root.Val &lt; rightRet.minVal,\n        maxVal: max(leftRet.maxVal, rightRet.maxVal, root.Val),\n        minVal: min(leftRet.minVal, rightRet.minVal, root.Val),\n    }\n}\n</code></pre>"},{"location":"hot100/doublePointers/LC11/","title":"LC11 - \u76db\u6c34\u6700\u591a\u7684\u5bb9\u5668","text":"ContainerWithMostWater.go<pre><code>package DoublePointers\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc maxArea(height []int) int {\n    left, right := 0, len(height)-1\n    result := (right - left) * min(height[left], height[right])\n    for left &lt; right {\n        if height[left] &lt;= height[right] {\n            tmp := height[left]\n            for left &lt; right &amp;&amp; height[left] &lt;= tmp {\n                left++\n            }\n        } else {\n            tmp := height[right]\n            for left &lt; right &amp;&amp; height[right] &lt;= tmp {\n                right--\n            }\n        }\n        result = max(result, (right-left)*min(height[left], height[right]))\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/doublePointers/LC15/","title":"LC15 - \u4e09\u6570\u4e4b\u548c","text":"ThreeSum.go<pre><code>package DoublePointers\n\nimport \"slices\"\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n^2), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc threeSum(nums []int) [][]int {\n    slices.Sort(nums)\n    result := make([][]int, 0)\n    for i := 0; i &lt; len(nums)-2; i = next(i, nums) {\n        j, k := i+1, len(nums)-1\n        for j &lt; k {\n            if nums[i]+nums[j]+nums[k] == 0 {\n                result = append(result, []int{nums[i], nums[j], nums[k]})\n                j = next(j, nums)\n                k = prev(k, nums)\n            } else if nums[i]+nums[j]+nums[k] &lt; 0 {\n                j = next(j, nums)\n            } else {\n                k = prev(k, nums)\n            }\n        }\n    }\n    return result\n}\n\nfunc next(i int, nums []int) int {\n    length := len(nums)\n    for ; i+1 &lt; length &amp;&amp; nums[i] == nums[i+1]; i++ {\n    }\n    return i + 1\n}\n\nfunc prev(i int, nums []int) int {\n    for ; i-1 &gt;= 0 &amp;&amp; nums[i] == nums[i-1]; i-- {\n    }\n    return i - 1\n}\n</code></pre> <p>\u672c\u9898\u4e0eLC1\u7684\u6700\u672c\u8d28\u533a\u522b\u5728\u4e8e\u53ea\u9700\u8fd4\u56de\u6570\u503c\u800c\u4e0d\u7528\u539f\u59cb\u6570\u7ec4\u7684\u4e0b\u6807\uff0c\u56e0\u6b64\u975e\u5e38\u9002\u5408\u4f7f\u7528\u53cc\u6307\u9488\u3002</p> <p>\u4e3a\u4e86\u5b9e\u73b0\u5bf9\u7ed3\u679c\u7684\u53bb\u91cd\uff0c\u9700\u8981\u5b9e\u73b0<code>next</code>\u51fd\u6570\u548c<code>prev</code>\u51fd\u6570\u4ee5\u53d6\u4ee3\u539f\u672c\u7684--\u548c++\u3002</p>"},{"location":"hot100/doublePointers/LC283/","title":"LC283 - \u79fb\u52a8\u96f6","text":"MoveZeroes.go<pre><code>package DoublePointers\n\nfunc moveZeroes(nums []int) {\n    moveZeroes2(nums)\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n^2), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc moveZeroes1(nums []int) {\n    left, right := 0, len(nums)-1\n    for left &lt;= right {\n        if nums[left] == 0 {\n            moveToEnd(nums, left, right)\n            right--\n        } else {\n            left++\n        }\n    }\n}\n\nfunc moveToEnd(nums []int, left int, right int) {\n    tmp := nums[left]\n    for i := left; i &lt; right; i++ {\n        nums[i] = nums[i+1]\n    }\n    nums[right] = tmp\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc moveZeroes2(nums []int) {\n    left, right := 0, 0\n    for right &lt; len(nums) {\n        if nums[right] != 0 {\n            nums[left], nums[right] = nums[right], nums[left]\n            left++\n        }\n        right++\n    }\n}\n</code></pre> <p><code>moveZeroes1</code>\u65b9\u6cd5\u4e2d\uff0c\u53f3\u4fa7\u6307\u9488\u7ef4\u62a4\u96f6\u533a\uff0c\u7531\u4e8e\u9898\u76ee\u8981\u6c42\u6240\u6709\u975e\u96f6\u6570\u503c\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4fdd\u6301\u4e0d\u53d8\uff0c\u56e0\u6b64\u4e0d\u80fd\u7b80\u5355\u4ea4\u6362\u5de6\u53f3\u6307\u9488\u6307\u5411\u7684\u6570\u5b57\uff0c\u5fc5\u987b\u8fdb\u884c\u6574\u4f53\u7684\u632a\u52a8\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n^2)\u3002</p> <p><code>moveZeroes2</code>\u65b9\u6cd5\u4e2d\uff0c\u5de6\u4fa7\u6307\u9488\u7ef4\u62a4\u975e\u96f6\u533a\uff0c\u4ea4\u6362\u64cd\u4f5c\u53ef\u4ee5\u7ef4\u6301\u6240\u6709\u975e\u96f6\u6570\u503c\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4fdd\u6301\u4e0d\u53d8\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n)\u3002</p>"},{"location":"hot100/doublePointers/LC42/","title":"LC42 - \u63a5\u96e8\u6c34","text":"TrappingRainWater.go<pre><code>package DoublePointers\n\nfunc trap(height []int) int {\n    return trap1(height)\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc trap1(height []int) int {\n    size := len(height)\n    lmax := make([]int, size)\n    lmax[0] = height[0]\n    for i := 1; i &lt; size; i++ {\n        lmax[i] = max(lmax[i-1], height[i])\n    }\n    rmax := make([]int, size)\n    rmax[size-1] = height[size-1]\n    for j := size - 2; j &gt;= 0; j-- {\n        rmax[j] = max(rmax[j+1], height[j])\n    }\n    result := 0\n    for i := 1; i &lt; size-1; i++ {\n        limit := min(lmax[i-1], rmax[i+1])\n        curVolume := max(0, limit-height[i])\n        result += curVolume\n    }\n    return result\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc trap2(height []int) int {\n    left, right := 1, len(height)-2\n    lmax, rmax := height[0], height[len(height)-1]\n    result := 0\n    for left &lt;= right {\n        if lmax &lt;= rmax {\n            result += max(0, lmax-height[left])\n            lmax = max(lmax, height[left])\n            left++\n        } else {\n            result += max(0, rmax-height[right])\n            rmax = max(rmax, height[right])\n            right--\n        }\n    }\n    return result\n}\n</code></pre> <p>\u6bcf\u4e2a\u683c\u5b50\u7684\u6c34\u4f4d\u7ebf\u53d6\u51b3\u4e8e\u5de6\u4fa7\u6700\u5927\u9ad8\u5ea6\u548c\u53f3\u4fa7\u6700\u5927\u9ad8\u5ea6\u7684\u8f83\u5c0f\u503c\u3002</p>"},{"location":"hot100/dp/LC118/","title":"LC118 - \u6768\u8f89\u4e09\u89d2","text":"PascalsTriangle.go<pre><code>package DP\n\nfunc generate(numRows int) [][]int {\n    result := make([][]int, numRows)\n    for i := 0; i &lt; numRows; i++ {\n        result[i] = make([]int, i+1)\n        for j := 0; j &lt;= i; j++ {\n            if j == 0 || j == i {\n                result[i][j] = 1\n            } else {\n                result[i][j] = result[i-1][j-1] + result[i-1][j]\n            }\n        }\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/dp/LC139/","title":"LC139 - \u5355\u8bcd\u62c6\u5206","text":"WordBreak.go<pre><code>package DP\n\nimport \"strings\"\n\nfunc wordBreak(s string, wordDict []string) bool {\n    size := len(s)\n    dp := make([]int, size)\n    for i := 0; i &lt; len(dp); i++ {\n        dp[i] = -1\n    }\n    var f func(int) bool\n    f = func(index int) bool {\n        if index == size {\n            return true\n        }\n        if dp[index] != -1 {\n            return dp[index] == 1\n        }\n        ret := false\n        for _, word := range wordDict {\n            ret = ret || startsWith(s, word, index) &amp;&amp; f(index+len(word))\n        }\n        if ret {\n            dp[index] = 1\n        } else {\n            dp[index] = 0\n        }\n        return ret\n    }\n    return f(0)\n}\n\nfunc startsWith(s, word string, index int) bool {\n    curStr := s[index:]\n    return strings.HasPrefix(curStr, word)\n}\n</code></pre>"},{"location":"hot100/dp/LC152/","title":"LC152 - \u4e58\u79ef\u6700\u5927\u5b50\u6570\u7ec4","text":"MaximumProductSubarray.go<pre><code>package DP\n\nfunc maxProduct(nums []int) int {\n    size := len(nums)\n    dpMin := make([]int, size)\n    dpMax := make([]int, size)\n    dpMin[0] = nums[0]\n    dpMax[0] = nums[0]\n    ans := dpMax[0]\n    for i := 1; i &lt; size; i++ {\n        dpMin[i] = min(nums[i], dpMin[i-1]*nums[i], dpMax[i-1]*nums[i])\n        dpMax[i] = max(nums[i], dpMax[i-1]*nums[i], dpMin[i-1]*nums[i])\n        ans = max(ans, dpMax[i])\n    }\n    return ans\n}\n</code></pre>"},{"location":"hot100/dp/LC198/","title":"LC198 - \u6253\u5bb6\u52ab\u820d","text":"HouseRobber.go<pre><code>package DP\n\n//func rob(nums []int) int {\n//  size := len(nums)\n//  var f func(int) int\n//  f = func(index int) int {\n//      if index &gt;= size {\n//          return 0\n//      }\n//      ret1 := nums[index] + f(index+2)\n//      ret2 := f(index + 1)\n//      return max(ret1, ret2)\n//  }\n//  return f(0)\n//}\n\nfunc rob(nums []int) int {\n    // dp[i] = max(dp[i+1], nums[i] + dp[i+2])\n    size := len(nums)\n    dp := make([]int, size+2)\n    for i := size - 1; i &gt;= 0; i-- {\n        dp[i] = max(dp[i+1], nums[i]+dp[i+2])\n    }\n    return dp[0]\n}\n</code></pre>"},{"location":"hot100/dp/LC279/","title":"LC279 - \u5b8c\u5168\u5e73\u65b9\u6570","text":"PerfectSquares.go<pre><code>package DP\n\nimport \"math\"\n\nfunc numSquares(n int) int {\n    return numSquares2(n)\n}\n\n//func numSquares(n int) int {\n//  // 1 &lt;= n &lt;= 10000\n//  var f func(int, int) int\n//  f = func(index, rest int) int {\n//      if index == 0 {\n//          if rest == 0 {\n//              return 0\n//          } else {\n//              return math.MaxInt\n//          }\n//      }\n//      cur := index * index\n//      if rest &lt; cur {\n//          return f(index-1, rest)\n//      } else {\n//          return min(f(index, rest-cur)+1, f(index-1, rest))\n//      }\n//  }\n//  return f(100, n)\n//}\n\n// \u4e8c\u7ef4DP\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * \u221an), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n * \u221an)\nfunc numSquares1(n int) int {\n    // 1 &lt;= n &lt;= 10000\n    // dp[i][j] -&gt; dp[i-1][j], dp[i][j-x]\n    dp := make([][]int, 101)\n    for i := 0; i &lt; len(dp); i++ {\n        dp[i] = make([]int, n+1)\n    }\n    for j := 1; j &lt;= n; j++ {\n        dp[0][j] = math.MaxInt\n    }\n    for i := 1; i &lt;= 100; i++ {\n        for j := 1; j &lt;= n; j++ {\n            cur := i * i\n            if j &lt; cur {\n                dp[i][j] = dp[i-1][j]\n            } else {\n                dp[i][j] = min(dp[i-1][j], dp[i][j-cur]+1)\n            }\n        }\n    }\n    return dp[100][n]\n}\n\n// \u4e00\u7ef4DP\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * \u221an), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc numSquares2(n int) int {\n    // dp[i] = min(dp[i], dp[i-j*j]+1)\n    dp := make([]int, n+1)\n    for i := 1; i &lt;= n; i++ {\n        dp[i] = math.MaxInt\n    }\n    for i := 1; i &lt;= n; i++ {\n        for j := 1; j*j &lt;= i; j++ {\n            dp[i] = min(dp[i], dp[i-j*j]+1)\n        }\n    }\n    return dp[n]\n}\n</code></pre> <p>\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230\u7684\u65b9\u6cd5\u662f\u4e8c\u7ef4\u52a8\u6001\u89c4\u5212(<code>numSquares1</code>)\uff0c\u4f46\u6700\u4f18\u89e3\u662f\u4e00\u7ef4\u52a8\u6001\u89c4\u5212(<code>numSquares2</code>)\u3002</p>"},{"location":"hot100/dp/LC300/","title":"LC300 - \u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217","text":"LongestIncreasingSubsequence.go<pre><code>package DP\n\nimport \"math\"\n\n// lengthOfLIS: \u6c42\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217\u957f\u5ea6\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * log n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n) &lt;\u6700\u4f18\u89e3&gt;\nfunc lengthOfLIS(nums []int) int {\n    size := len(nums)\n    dp := make([]int, size)\n    // dp[i]: \u4ee5i\u4f4d\u7f6e\u4f5c\u4e3a\u7ed3\u5c3e\u7684\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217\u957f\u5ea6\n    ends := make([]int, 0)\n    // ends[i]\uff1a\u957f\u5ea6\u4e3ai+1\u7684\u9012\u589e\u5b50\u5e8f\u5217\u7684\u6700\u5c0f\u7ed3\u5c3e\n    ans := math.MinInt\n    for i := 0; i &lt; size; i++ {\n        pos := find(ends, nums[i])\n        if pos == len(ends) {\n            ends = append(ends, nums[i])\n        } else {\n            ends[pos] = nums[i]\n        }\n        dp[i] = pos + 1\n        ans = max(ans, dp[i])\n    }\n    return ans\n}\n\n// find: \u5728\u9012\u589e\u5e8f\u5217\u4e2d\u627e\u5927\u4e8e\u7b49\u4e8etarget\u7684\u6700\u5de6\u4f4d\u7f6e\uff0c\u4e0d\u5b58\u5728\u5219\u8fd4\u56desize\nfunc find(arr []int, target int) int {\n    ans := len(arr)\n    for left, right := 0, ans-1; left &lt;= right; {\n        mid := left + (right-left)/2\n        if arr[mid] &gt;= target {\n            ans = mid\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return ans\n}\n</code></pre> <p>\u5177\u4f53\u5206\u6790\u8fc7\u7a0b\u53c2\u52a0\u5de6\u795e\u7b97\u6cd5\u8bb2\u89e3</p>"},{"location":"hot100/dp/LC32/","title":"LC32 - \u6700\u957f\u6709\u6548\u62ec\u53f7","text":"LongestValidParentheses.go<pre><code>package DP\n\nfunc longestValidParentheses(s string) int {\n    size := len(s)\n    dp := make([]int, size)\n    ans := 0\n    for i := 1; i &lt; size; i++ {\n        if s[i] == '(' {\n            // (1) \u5f53\u524d\u4f4d\u7f6e\u4e3a\u5de6\u62ec\u53f7\uff0c\u76f4\u63a5\u53d60\n            dp[i] = 0\n        } else {\n            tmp := dp[i-1]\n            if i-1-tmp &lt; 0 || s[i-1-tmp] == ')' {\n                // (2) tmp\u4f4d\u7f6e\u4e0d\u5b58\u5728\u6216\u4e3a\u53f3\u62ec\u53f7\uff0c\u76f4\u63a5\u53d60\n                dp[i] = 0\n            } else {\n                // (3) \u5f53\u524d\u4f4d\u7f6e\u7684\u6709\u6548\u62ec\u53f7\u4e32\u957f\u5ea6\u81f3\u5c11\u6709 2+tmp\n                dp[i] = 2 + tmp\n                if i-2-tmp &gt;= 0 {\n                    // (4) \u82e5i-2-tmp\u4f4d\u7f6e\u5b58\u5728\uff0c\u5219\u5c06\u5176\u5bf9\u5e94\u957f\u5ea6\u52a0\u5230\u5f53\u524d\u4f4d\u7f6e\n                    dp[i] += dp[i-2-tmp]\n                }\n            }\n        }\n        ans = max(ans, dp[i])\n    }\n    return ans\n}\n</code></pre> <p>\u672c\u9898\u96be\u5ea6\u76f8\u5bf9\u8f83\u5927\uff0c\u5efa\u8bae\u80cc\u9898\uff0c\u66f4\u8be6\u7ec6\u7684\u5206\u6790\u8fc7\u7a0b\u53c2\u89c1\u5de6\u795e\u7b97\u6cd5\u8bb2\u89e3\u3002</p>"},{"location":"hot100/dp/LC322/","title":"LC322 - \u96f6\u94b1\u5151\u6362","text":"CoinChange.go<pre><code>package DP\n\nimport \"math\"\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n// n\u8868\u793a\u603b\u91d1\u989damount, m\u8868\u793a\u4e0d\u540c\u9762\u503c\u786c\u5e01\u7684\u79cd\u6570\nfunc coinChange(coins []int, amount int) int {\n    size := len(coins)\n    dp := make([]int, amount+1)\n    for i := 1; i &lt;= amount; i++ {\n        dp[i] = math.MaxInt\n    }\n    for i := 1; i &lt;= amount; i++ {\n        for j := 0; j &lt; size; j++ {\n            if coins[j] &gt; i || dp[i-coins[j]] == math.MaxInt {\n                continue\n            }\n            dp[i] = min(dp[i], dp[i-coins[j]]+1)\n        }\n    }\n    if dp[amount] == math.MaxInt {\n        return -1\n    }\n    return dp[amount]\n}\n</code></pre> <p>\u4e0e\u4e0a\u4e00\u9898 LC279 \u7c7b\u4f3c</p>"},{"location":"hot100/dp/LC416/","title":"LC416 - \u5206\u5272\u7b49\u548c\u5b50\u96c6","text":"PartitionEqualSubsetSum.go<pre><code>package DP\n\n//func canPartition(nums []int) bool {\n//  size := len(nums)\n//  sum := 0\n//  for i := 0; i &lt; size; i++ {\n//      sum += nums[i]\n//  }\n//  if sum%2 != 0 {\n//      return false\n//  }\n//  target := sum / 2\n//  var f func(int, int) bool\n//  f = func(index, rest int) bool {\n//      if index == size {\n//          return rest == 0\n//      }\n//      ret1 := f(index+1, rest)\n//      ret2 := false\n//      if rest &gt;= nums[index] {\n//          ret2 = f(index+1, rest-nums[index])\n//      }\n//      return ret1 || ret2\n//  }\n//  return f(0, target)\n//}\n\nfunc canPartition(nums []int) bool {\n    size := len(nums)\n    sum := 0\n    for i := 0; i &lt; size; i++ {\n        sum += nums[i]\n    }\n    if sum%2 != 0 {\n        return false\n    }\n    target := sum / 2\n    dp := make([][]bool, size+1)\n    for i := 0; i &lt;= size; i++ {\n        dp[i] = make([]bool, target+1)\n    }\n    dp[size][0] = true\n    for i := size - 1; i &gt;= 0; i-- {\n        for j := 0; j &lt;= target; j++ {\n            dp[i][j] = dp[i+1][j]\n            if j &gt;= nums[i] {\n                dp[i][j] = dp[i][j] || dp[i+1][j-nums[i]]\n            }\n        }\n    }\n    return dp[0][target]\n}\n</code></pre>"},{"location":"hot100/dp/LC70/","title":"LC70 - \u722c\u697c\u68af","text":"ClimbingStairs.go<pre><code>package DP\n\nfunc climbStairs(n int) int {\n    dp := make([]int, n+1)\n    dp[0], dp[1] = 1, 1\n    for i := 2; i &lt;= n; i++ {\n        dp[i] = dp[i-1] + dp[i-2]\n    }\n    return dp[n]\n}\n</code></pre>"},{"location":"hot100/graph/LC200/","title":"LC200 - \u5c9b\u5c7f\u6570\u91cf","text":"NumberOfIslands.go<pre><code>package Graph\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n * m)\nfunc numIslands(grid [][]byte) int {\n    n, m := len(grid), len(grid[0])\n    islands := 0\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; m; j++ {\n            if grid[i][j] == '1' {\n                islands++\n                infect(grid, i, j)\n            }\n        }\n    }\n    return islands\n}\n\nfunc infect(grid [][]byte, i, j int) {\n    if i &lt; 0 || i &gt;= len(grid) || j &lt; 0 || j &gt;= len(grid[0]) || grid[i][j] != '1' {\n        return\n    }\n    grid[i][j] = '2'\n    infect(grid, i-1, j)\n    infect(grid, i+1, j)\n    infect(grid, i, j-1)\n    infect(grid, i, j+1)\n}\n</code></pre> <p>\u6d2a\u6c34\u586b\u5145</p>"},{"location":"hot100/graph/LC207/","title":"LC207 - \u8bfe\u7a0b\u8868","text":"CourseSchedule.go<pre><code>package Graph\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n + m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n + m)\n// n\u4e3a\u70b9\u7684\u6570\u91cf, m\u4e3a\u8fb9\u7684\u6570\u91cf\nfunc canFinish(numCourses int, prerequisites [][]int) bool {\n    graph := make([][]int, numCourses)\n    inDegree := make([]int, numCourses)\n    for _, prerequisite := range prerequisites {\n        from, to := prerequisite[1], prerequisite[0]\n        graph[from] = append(graph[from], to)\n        inDegree[to]++\n    }\n    queue := new(Queue[int])\n    for i := 0; i &lt; numCourses; i++ {\n        if inDegree[i] == 0 {\n            queue.Enqueue(i)\n        }\n    }\n    for !queue.IsEmpty() {\n        cur := queue.Dequeue()\n        for _, next := range graph[cur] {\n            inDegree[next]--\n            if inDegree[next] == 0 {\n                queue.Enqueue(next)\n            }\n        }\n    }\n    for i := 0; i &lt; numCourses; i++ {\n        if inDegree[i] != 0 {\n            return false\n        }\n    }\n    return true\n}\n</code></pre> <p>\u62d3\u6251\u6392\u5e8f</p>"},{"location":"hot100/graph/LC208/","title":"LC208 - \u5b9e\u73b0 Trie (\u524d\u7f00\u6811)","text":"ImplementTrie.go<pre><code>package Graph\n\ntype TrieNode struct {\n    pass, end int\n    nexts     [26]*TrieNode\n}\ntype Trie struct {\n    root *TrieNode\n}\n\nfunc Constructor() Trie {\n    trie := new(Trie)\n    trie.root = new(TrieNode)\n    return *trie\n}\n\nfunc (this *Trie) Insert(word string) {\n    cur := this.root\n    cur.pass++\n    for _, ch := range word {\n        if cur.nexts[ch-'a'] == nil {\n            cur.nexts[ch-'a'] = new(TrieNode)\n        }\n        cur = cur.nexts[ch-'a']\n        cur.pass++\n    }\n    cur.end++\n}\n\nfunc (this *Trie) Search(word string) bool {\n    cur := this.root\n    for _, ch := range word {\n        if cur.nexts[ch-'a'] == nil {\n            return false\n        }\n        cur = cur.nexts[ch-'a']\n    }\n    return cur.end &gt; 0\n}\n\nfunc (this *Trie) StartsWith(prefix string) bool {\n    cur := this.root\n    for _, ch := range prefix {\n        if cur.nexts[ch-'a'] == nil {\n            return false\n        }\n        cur = cur.nexts[ch-'a']\n    }\n    return true\n}\n\nfunc (this *Trie) Count(word string) int {\n    cur := this.root\n    for _, ch := range word {\n        if cur.nexts[ch-'a'] == nil {\n            return 0\n        }\n        cur = cur.nexts[ch-'a']\n    }\n    return cur.end\n}\n\nfunc (this *Trie) CountPrefix(prefix string) int {\n    cur := this.root\n    for _, ch := range prefix {\n        if cur.nexts[ch-'a'] == nil {\n            return 0\n        }\n        cur = cur.nexts[ch-'a']\n    }\n    return cur.pass\n}\n\nfunc (this *Trie) Delete(word string) {\n    if !this.Search(word) {\n        return\n    }\n    cur := this.root\n    cur.pass--\n    for _, ch := range word {\n        cur.nexts[ch-'a'].pass--\n        if cur.nexts[ch-'a'].pass == 0 {\n            cur.nexts[ch-'a'] = nil\n            return\n        }\n        cur = cur.nexts[ch-'a']\n    }\n    cur.end--\n}\n</code></pre>"},{"location":"hot100/graph/LC994/","title":"LC994 - \u8150\u70c2\u7684\u6a58\u5b50","text":"RottingOranges.go<pre><code>package Graph\n\ntype Pos struct {\n    x, y int\n}\n\n// Queue is a generic type.\ntype Queue[T any] []T\n\n// Size returns the number of elements in the queue.\nfunc (q *Queue[T]) Size() int {\n    return len(*q)\n}\n\n// IsEmpty checks if the queue is empty.\nfunc (q *Queue[T]) IsEmpty() bool {\n    return len(*q) == 0\n}\n\n// Enqueue adds an element to the back of the queue.\nfunc (q *Queue[T]) Enqueue(e T) {\n    *q = append(*q, e)\n}\n\n// Dequeue removes and returns the element from the front of the queue.\nfunc (q *Queue[T]) Dequeue() T {\n    if q.IsEmpty() {\n        var zero T // Return the zero value of type T if the queue is empty.\n        return zero\n    }\n    e := (*q)[0]\n    *q = (*q)[1:]\n    return e\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n * m)\nfunc orangesRotting(grid [][]int) int {\n    n, m := len(grid), len(grid[0])\n    move := [5]int{-1, 0, 1, 0, -1}\n    queue := new(Queue[*Pos])\n    allZero := true\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; m; j++ {\n            if grid[i][j] != 0 {\n                allZero = false\n            }\n            if grid[i][j] == 2 {\n                queue.Enqueue(&amp;Pos{i, j})\n            }\n        }\n    }\n    if allZero {\n        return 0\n    }\n    curLevel := 0\n    for !queue.IsEmpty() {\n        curLevelSize := queue.Size()\n        for i := 0; i &lt; curLevelSize; i++ {\n            curPos := queue.Dequeue()\n            curX, curY := curPos.x, curPos.y\n            for j := 0; j &lt; 4; j++ {\n                nextX, nextY := curX+move[j], curY+move[j+1]\n                if nextX &gt;= 0 &amp;&amp; nextX &lt; n &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; m &amp;&amp; grid[nextX][nextY] == 1 {\n                    grid[nextX][nextY] = 2\n                    queue.Enqueue(&amp;Pos{nextX, nextY})\n                }\n            }\n        }\n        curLevel++\n    }\n    for i := 0; i &lt; n; i++ {\n        for j := 0; j &lt; m; j++ {\n            if grid[i][j] == 1 {\n                return -1\n            }\n        }\n    }\n    return curLevel - 1\n}\n</code></pre> <p>\u591a\u6e90BFS</p>"},{"location":"hot100/greedy/LC121/","title":"LC121 - \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a","text":"BestTimeToBuyAndSellStock.go<pre><code>package Greedy\n\nimport \"math\"\n\nfunc maxProfit(prices []int) int {\n    return maxProfit2(prices)\n}\n\nfunc maxProfit1(prices []int) int {\n    minPrices := make([]int, len(prices))\n    minPrices[0] = prices[0]\n    for i := 1; i &lt; len(prices); i++ {\n        minPrices[i] = min(minPrices[i-1], prices[i])\n    }\n    maxProfits := 0\n    for i := 0; i &lt; len(prices); i++ {\n        maxProfits = max(maxProfits, prices[i]-minPrices[i])\n    }\n    return maxProfits\n}\n\nfunc maxProfit2(prices []int) int {\n    minPrices, maxProfits := math.MaxInt, math.MinInt\n    for i := 0; i &lt; len(prices); i++ {\n        minPrices = min(minPrices, prices[i])\n        maxProfits = max(maxProfits, prices[i]-minPrices)\n    }\n    return maxProfits\n}\n</code></pre>"},{"location":"hot100/greedy/LC45/","title":"LC45 - \u8df3\u8dc3\u6e38\u620f II","text":"JumpGameII.go<pre><code>package Greedy\n\nfunc jump(nums []int) int {\n    cnt, cur, next := 0, 0, 0\n    // cnt : \u6b65\u6570\n    // cur :  cnt     \u6b65\u80fd\u591f\u8fbe\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\n    // next : cnt + 1 \u6b65\u80fd\u591f\u8fbe\u5230\u7684\u6700\u8fdc\u4f4d\u7f6e\n    for i := 0; i &lt; len(nums); i++ {\n        if cur &lt; i {\n            cnt++\n            cur = next\n        }\n        next = max(next, i+nums[i])\n    }\n    return cnt\n}\n</code></pre>"},{"location":"hot100/greedy/LC55/","title":"LC55 - \u8df3\u8dc3\u6e38\u620f","text":"JumpGame.go<pre><code>package Greedy\n\nfunc canJump(nums []int) bool {\n    cur, limit := 0, 0\n    for ; cur &lt;= limit; cur++ {\n        limit = max(limit, cur+nums[cur])\n        if limit &gt;= len(nums)-1 {\n            return true\n        }\n    }\n    return false\n}\n</code></pre>"},{"location":"hot100/greedy/LC763/","title":"LC763 - \u5212\u5206\u5b57\u6bcd\u533a\u95f4","text":"PartitionLabels.go<pre><code>package Greedy\n\nfunc partitionLabels(s string) []int {\n    hashTable := make(map[byte]int)\n    // hashTable\u8bb0\u5f55\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u6bcd\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\n    for i := 0; i &lt; len(s); i++ {\n        hashTable[s[i]] = i\n    }\n    result := make([]int, 0)\n    for cur := 0; cur &lt; len(s); {\n        tmp := cur\n        for limit := cur; cur &lt;= limit; cur++ {\n            limit = max(limit, hashTable[s[cur]])\n        }\n        result = append(result, cur-tmp)\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/hashTable/LC1/","title":"LC1 - \u4e24\u6570\u4e4b\u548c","text":"TwoSum.go<pre><code>package HashTable\n\nimport (\n    \"cmp\"\n    \"slices\"\n)\n\nfunc twoSum(nums []int, target int) []int {\n    return twoSum1(nums, target)\n}\n\ntype indexedNum struct {\n    Value int\n    Index int\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * log n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc twoSum1(nums []int, target int) []int {\n    indexedNums := make([]indexedNum, len(nums))\n    for i, num := range nums {\n        indexedNums[i] = indexedNum{num, i}\n    }\n    slices.SortFunc(indexedNums, func(a, b indexedNum) int {\n        return cmp.Compare(a.Value, b.Value)\n    })\n    left, right := 0, len(nums)-1\n    for left &lt; right {\n        sum := indexedNums[left].Value + indexedNums[right].Value\n        if sum == target {\n            return []int{indexedNums[left].Index, indexedNums[right].Index}\n        } else if sum &gt; target {\n            right--\n        } else {\n            left++\n        }\n    }\n    return nil\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc twoSum2(nums []int, target int) []int {\n    hashTable := make(map[int]int)\n    for index2, num2 := range nums {\n        num1 := target - num2\n        if index1, ok := hashTable[num1]; ok {\n            return []int{index1, index2}\n        } else {\n            hashTable[num2] = index2\n        }\n    }\n    return nil\n}\n</code></pre> <p>\u7b2c\u4e00\u53cd\u5e94\u662f\u6392\u5e8f\u540e\u53cc\u6307\u9488\uff0c\u4f46\u7531\u4e8e\u9700\u8981\u8fd4\u56de\u539f\u6570\u7ec4\u7d22\u5f15\u800c\u975e\u6570\u503c\uff0c\u56e0\u6b64\u5fc5\u987b\u501f\u52a9\u8f85\u52a9\u6570\u7ec4\u3002</p>"},{"location":"hot100/hashTable/LC128/","title":"LC128 - \u6700\u957f\u8fde\u7eed\u5e8f\u5217","text":"LongestConsecutiveSequence.go<pre><code>package HashTable\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc longestConsecutive(nums []int) int {\n    hashSet := make(map[int]bool)\n    for _, num := range nums {\n        hashSet[num] = true\n    }\n    result := 0\n    for num := range hashSet {\n        if hashSet[num-1] {\n            continue\n        }\n        tmp := num\n        for hashSet[tmp] {\n            tmp++\n        }\n        result = max(result, tmp-num)\n    }\n    return result\n}\n</code></pre> <p>\u6700\u5173\u952e\u7684\u90e8\u5206\u5c31\u662f11-13\u884c\uff0c\u6b63\u662f\u6709\u4e86\u8fd9\u91cc\u7684\u526a\u679d\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u624d\u5f97\u4ee5\u63a7\u5236\u5728O(n)\u3002</p> <p>\u9664\u6b64\u4ee5\u5916\u5fc5\u987b\u904d\u5386\u54c8\u5e0c\u8868\u800c\u975e\u539f\u59cb\u6570\u7ec4\uff0c\u56e0\u4e3a\u539f\u59cb\u6570\u636e\u4e2d\u53ef\u80fd\u5b58\u5728\u91cd\u590d\u6570\u5b57\uff0c\u5728\u7279\u5b9a\u60c5\u51b5\u4e0b(\u5982: 1111...2345...)\u4f1a\u4f7f\u65f6\u95f4\u590d\u6742\u5ea6\u8fbe\u5230O(n^2)\u89c4\u6a21\u3002</p>"},{"location":"hot100/hashTable/LC49/","title":"LC49 - \u5b57\u6bcd\u5f02\u4f4d\u8bcd\u5206\u7ec4","text":"GroupAnagrams.go<pre><code>package HashTable\n\nimport \"slices\"\n\nfunc groupAnagrams(strs []string) [][]string {\n    hashTable := make(map[string][]string)\n    for _, str := range strs {\n        strByte := []byte(str)\n        slices.Sort(strByte)\n        s := string(strByte)\n        hashTable[s] = append(hashTable[s], str)\n    }\n    result := make([][]string, 0)\n    for _, group := range hashTable {\n        result = append(result, group)\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/heap/LC215/","title":"LC215 - \u6570\u7ec4\u4e2d\u7684\u7b2cK\u4e2a\u6700\u5927\u5143\u7d20","text":"KthLargestElement.go<pre><code>package Heap\n\nimport (\n    \"cmp\"\n    \"container/heap\"\n)\n\n// EasyMinHeap is a generic type.\n// The elements should be basic data types.\ntype EasyMinHeap[T cmp.Ordered] []T\n\nfunc (h EasyMinHeap[T]) Len() int {\n    return len(h)\n}\n\nfunc (h EasyMinHeap[T]) Less(i, j int) bool {\n    return h[i] &lt; h[j]\n}\n\nfunc (h EasyMinHeap[T]) Swap(i, j int) {\n    h[i], h[j] = h[j], h[i]\n}\n\nfunc (h *EasyMinHeap[T]) Push(x interface{}) {\n    *h = append(*h, x.(T))\n}\n\nfunc (h *EasyMinHeap[T]) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\nfunc (h *EasyMinHeap[T]) Top() interface{} {\n    if h.Len() == 0 {\n        return nil\n    } else {\n        return (*h)[0]\n    }\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * log k), \u7a7a\u95f4\u590d\u6742\u5ea6: O(k)\nfunc findKthLargest(nums []int, k int) int {\n    minHeap := new(EasyMinHeap[int])\n    heap.Init(minHeap)\n    for _, num := range nums {\n        if minHeap.Len() &lt; k {\n            heap.Push(minHeap, num)\n        } else if num &gt; minHeap.Top().(int) {\n            heap.Push(minHeap, num)\n            heap.Pop(minHeap)\n        }\n    }\n    return heap.Pop(minHeap).(int)\n}\n</code></pre>"},{"location":"hot100/heap/LC295/","title":"LC295 - \u6570\u636e\u6d41\u7684\u4e2d\u4f4d\u6570","text":"FindMedianFromDataStream.go<pre><code>package Heap\n\nimport (\n    \"cmp\"\n    \"container/heap\"\n)\n\n// EasyMaxHeap is a generic type.\n// The elements should be basic data types.\ntype EasyMaxHeap[T cmp.Ordered] []T\n\nfunc (h EasyMaxHeap[T]) Len() int {\n    return len(h)\n}\n\nfunc (h EasyMaxHeap[T]) Less(i, j int) bool {\n    return h[i] &gt; h[j]\n}\n\nfunc (h EasyMaxHeap[T]) Swap(i, j int) {\n    h[i], h[j] = h[j], h[i]\n}\n\nfunc (h *EasyMaxHeap[T]) Push(x interface{}) {\n    *h = append(*h, x.(T))\n}\n\nfunc (h *EasyMaxHeap[T]) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\nfunc (h *EasyMaxHeap[T]) Top() interface{} {\n    if h.Len() == 0 {\n        return nil\n    } else {\n        return (*h)[0]\n    }\n}\n\ntype MedianFinder struct {\n    maxHeap *EasyMaxHeap[int]\n    minHeap *EasyMinHeap[int]\n}\n\nfunc Constructor() MedianFinder {\n    medianFinder := &amp;MedianFinder{\n        maxHeap: new(EasyMaxHeap[int]),\n        minHeap: new(EasyMinHeap[int]),\n    }\n    heap.Init(medianFinder.maxHeap)\n    heap.Init(medianFinder.minHeap)\n    return *medianFinder\n}\n\nfunc (this *MedianFinder) AddNum(num int) {\n    if this.maxHeap.Len() == 0 || num &lt;= this.maxHeap.Top().(int) {\n        heap.Push(this.maxHeap, num)\n        if this.maxHeap.Len()-this.minHeap.Len() &gt; 1 {\n            heap.Push(this.minHeap, heap.Pop(this.maxHeap))\n        }\n    } else {\n        heap.Push(this.minHeap, num)\n        if this.maxHeap.Len() &lt; this.minHeap.Len() {\n            heap.Push(this.maxHeap, heap.Pop(this.minHeap))\n        }\n    }\n}\n\nfunc (this *MedianFinder) FindMedian() float64 {\n    if this.maxHeap.Len() == this.minHeap.Len() {\n        return float64(this.maxHeap.Top().(int)+this.minHeap.Top().(int)) / 2\n    } else {\n        return float64(this.maxHeap.Top().(int))\n    }\n}\n</code></pre> <p>\u6838\u5fc3\u601d\u60f3\u5c31\u662f\u5927\u6839\u5806\u4fdd\u5b58\u8f83\u5c0f\u7684\u4e00\u534a\uff0c\u5c0f\u6839\u5806\u4fdd\u5b58\u8f83\u5927\u7684\u4e00\u534a\u3002</p>"},{"location":"hot100/heap/LC347/","title":"LC347 - \u524dK\u4e2a\u9ad8\u9891\u5143\u7d20","text":"TopKFrequentElements.go<pre><code>package Heap\n\nimport (\n    \"container/heap\"\n)\n\n// Comparable is an interface.\ntype Comparable[T interface{}] interface {\n    MyLess(other T) bool\n}\n\n// MyHeap is a generic type.\n// The elements could be user-defined data types.\n// You should also implement the interface 'Comparable'.\ntype MyHeap[T Comparable[T]] []T\n\nfunc (h MyHeap[T]) Len() int {\n    return len(h)\n}\n\nfunc (h MyHeap[T]) Less(i, j int) bool {\n    return h[i].MyLess(h[j])\n}\n\nfunc (h MyHeap[T]) Swap(i, j int) {\n    h[i], h[j] = h[j], h[i]\n}\n\nfunc (h *MyHeap[T]) Push(x interface{}) {\n    *h = append(*h, x.(T))\n}\n\nfunc (h *MyHeap[T]) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\nfunc (h *MyHeap[T]) Top() interface{} {\n    if h.Len() == 0 {\n        return nil\n    } else {\n        return (*h)[0]\n    }\n}\n\ntype Frequency struct {\n    val, freq int\n}\n\nfunc (cur *Frequency) MyLess(other *Frequency) bool {\n    return cur.freq &lt; other.freq\n}\n\nfunc topKFrequent(nums []int, k int) []int {\n    hashTable := make(map[int]int)\n    for _, num := range nums {\n        hashTable[num]++\n    }\n    minHeap := new(MyHeap[*Frequency])\n    heap.Init(minHeap)\n    for val, freq := range hashTable {\n        if minHeap.Len() &lt; k {\n            heap.Push(minHeap, &amp;Frequency{val, freq})\n        } else if freq &gt; minHeap.Top().(*Frequency).freq {\n            heap.Push(minHeap, &amp;Frequency{val, freq})\n            heap.Pop(minHeap)\n        }\n    }\n    result := make([]int, 0)\n    for minHeap.Len() &gt; 0 {\n        result = append(result, heap.Pop(minHeap).(*Frequency).val)\n    }\n    return result\n}\n</code></pre> <p>\u672c\u9898\u7684\u903b\u8f91\u548c\u4e0a\u9898LC215\u51e0\u4e4e\u6ca1\u6709\u533a\u522b\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\u5982\u4f55\u5229\u7528\u6cdb\u578b\u63a5\u53e3\u5b9e\u73b0\u81ea\u5b9a\u4e49\u6570\u636e\u7c7b\u578b\u7684\u5806\u7ed3\u6784\u3002</p>"},{"location":"hot100/linkedList/LC138/","title":"LC138 - \u968f\u673a\u94fe\u8868\u7684\u590d\u5236","text":"CopyListWithRandomPointer.go<pre><code>package LinkedList\n\ntype Node struct {\n    Val    int\n    Next   *Node\n    Random *Node\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc copyRandomList(head *Node) *Node {\n    if head == nil {\n        return nil\n    }\n    for cur := head; cur != nil; cur = cur.Next.Next {\n        copyNode := new(Node)\n        copyNode.Val = cur.Val\n        copyNode.Next = cur.Next\n        cur.Next = copyNode\n    }\n    for cur := head; cur != nil; cur = cur.Next.Next {\n        copyNode := cur.Next\n        if cur.Random != nil {\n            copyNode.Random = cur.Random.Next\n        } else {\n            copyNode.Random = nil\n        }\n    }\n    copyHead := head.Next\n    for cur := head; cur != nil; cur = cur.Next {\n        copyNode := cur.Next\n        cur.Next = copyNode.Next\n        if copyNode.Next != nil {\n            copyNode.Next = copyNode.Next.Next\n        } else {\n            copyNode.Next = nil\n        }\n    }\n    return copyHead\n}\n</code></pre>"},{"location":"hot100/linkedList/LC141/","title":"LC141 - \u73af\u5f62\u94fe\u8868","text":"LinkedListCycle.go<pre><code>package LinkedList\n\nfunc hasCycle(head *ListNode) bool {\n    slow, fast := head, head\n    for fast != nil &amp;&amp; fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            return true\n        }\n    }\n    return false\n}\n</code></pre> <p>\u5feb\u6162\u6307\u9488\u3002\u82e5\u94fe\u8868\u6709\u73af\uff0c\u5219\u5feb\u6162\u6307\u9488\u5fc5\u7136\u4f1a\u5728\u73af\u4e0a\u91cd\u65b0\u76f8\u9047\uff1b\u5426\u5219\u5fc5\u7136\u4e0d\u4f1a\u91cd\u65b0\u76f8\u9047\u3002</p>"},{"location":"hot100/linkedList/LC142/","title":"LC142 - \u73af\u5f62\u94fe\u8868II","text":"LinkedListCycle.go<pre><code>func detectCycle(head *ListNode) *ListNode {\n    slow, fast := head, head\n    for fast != nil &amp;&amp; fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            break\n        }\n    }\n    if fast == nil || fast.Next == nil {\n        return nil\n    }\n    fast = head\n    for {\n        if slow == fast {\n            return slow\n        }\n        slow = slow.Next\n        fast = fast.Next\n    }\n}\n</code></pre> <p>\u5feb\u6162\u6307\u9488\u3002\u82e5\u94fe\u8868\u6709\u73af\uff0c\u5219\u5feb\u6162\u6307\u9488\u5fc5\u7136\u4f1a\u5728\u73af\u4e0a\u91cd\u65b0\u76f8\u9047\uff0c\u6b64\u65f6\u5c06\u5feb\u6307\u9488\u91cd\u65b0\u5f52\u4f4d\u81f3\u5934\u8282\u70b9\uff0c\u5feb\u6162\u6307\u9488\u6bcf\u6b21\u8d70\u4e00\u6b65\uff0c\u76f8\u9047\u4f4d\u7f6e\u5373\u4e3a\u5165\u73af\u8282\u70b9\u3002</p>"},{"location":"hot100/linkedList/LC146/","title":"LC146 - LRU\u7f13\u5b58","text":"LRUCache.go<pre><code>package LinkedList\n\ntype LRUNode struct {\n    key, val   int\n    prev, next *LRUNode\n}\ntype LRUCache struct {\n    size, capacity int\n    hashMap        map[int]*LRUNode\n    virtualHead    *LRUNode\n    virtualTail    *LRUNode\n}\n\nfunc Constructor(capacity int) LRUCache {\n    cache := LRUCache{\n        size:        0,\n        capacity:    capacity,\n        hashMap:     make(map[int]*LRUNode),\n        virtualHead: new(LRUNode),\n        virtualTail: new(LRUNode),\n    }\n    cache.virtualHead.next = cache.virtualTail\n    cache.virtualTail.prev = cache.virtualHead\n    return cache\n}\n\n// Get \u5355\u6b21\u64cd\u4f5c\u65f6\u95f4\u590d\u6742\u5ea6: O(1)\nfunc (this *LRUCache) Get(key int) int {\n    if node, ok := this.hashMap[key]; !ok {\n        return -1\n    } else {\n        ret := node.val\n        this.moveToHead(node)\n        return ret\n    }\n}\n\n// Put \u5355\u6b21\u64cd\u4f5c\u65f6\u95f4\u590d\u6742\u5ea6: O(1)\nfunc (this *LRUCache) Put(key int, value int) {\n    if node, ok := this.hashMap[key]; ok {\n        node.val = value\n        this.moveToHead(node)\n    } else {\n        node = new(LRUNode)\n        node.key = key\n        node.val = value\n        this.hashMap[key] = node\n        this.insertToHead(node)\n        if this.size == this.capacity {\n            last := this.virtualTail.prev\n            delete(this.hashMap, last.key)\n            this.removeAtTail()\n        } else {\n            this.size++\n        }\n    }\n}\n\nfunc (this *LRUCache) moveToHead(node *LRUNode) {\n    node.prev.next = node.next\n    node.next.prev = node.prev\n    first := this.virtualHead.next\n    this.virtualHead.next = node\n    node.prev = this.virtualHead\n    node.next = first\n    first.prev = node\n}\n\nfunc (this *LRUCache) insertToHead(node *LRUNode) {\n    first := this.virtualHead.next\n    this.virtualHead.next = node\n    node.prev = this.virtualHead\n    node.next = first\n    first.prev = node\n}\n\nfunc (this *LRUCache) removeAtTail() {\n    lastPrev := this.virtualTail.prev.prev\n    lastPrev.next = this.virtualTail\n    this.virtualTail.prev = lastPrev\n}\n</code></pre> <p>\u636e\u8bf4\u662f\u5927\u5382\u624b\u6495\u6700\u9ad8\u9891\u8003\u9898\u3002</p> <p>\u54c8\u5e0c\u8868 + \u53cc\u5411\u94fe\u8868\u3002</p>"},{"location":"hot100/linkedList/LC148/","title":"LC148 - \u6392\u5e8f\u94fe\u8868","text":"SortList.go<pre><code>package LinkedList\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * log n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(log n)\nfunc sortList(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    slow, fast := head, head\n    for fast.Next != nil &amp;&amp; fast.Next.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    fast = slow.Next\n    slow.Next = nil\n    head1 := sortList(head)\n    head2 := sortList(fast)\n    newHead := mergeTwoLists(head1, head2)\n    return newHead\n}\n</code></pre> <p><code>mergeTwoLists</code>\u51fd\u6570\u5728LC21\u4e2d\u5b9e\u73b0\u3002</p> <p>\u5f52\u5e76\u6392\u5e8f\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a\u9012\u5f52\u6df1\u5ea6O(log n)\u3002</p>"},{"location":"hot100/linkedList/LC160/","title":"LC160 - \u76f8\u4ea4\u94fe\u8868","text":"IntersectionOfTwoLinkedLists.go<pre><code>package LinkedList\n\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    curA, curB := headA, headB\n    lenA, lenB := 0, 0\n    for ; curA != nil; curA = curA.Next {\n        lenA++\n    }\n    for ; curB != nil; curB = curB.Next {\n        lenB++\n    }\n    curA, curB = headA, headB\n    if lenA &gt; lenB {\n        for i := 0; i &lt; lenA-lenB; i++ {\n            curA = curA.Next\n        }\n    } else {\n        for i := 0; i &lt; lenB-lenA; i++ {\n            curB = curB.Next\n        }\n    }\n    for curA != curB {\n        curA = curA.Next\n        curB = curB.Next\n    }\n    return curA\n}\n</code></pre>"},{"location":"hot100/linkedList/LC19/","title":"LC19 - \u5220\u9664\u94fe\u8868\u7684\u5012\u6570\u7b2cN\u4e2a\u8282\u70b9","text":"RemoveNthNodeFromEndOfList.go<pre><code>package LinkedList\n\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    slow, fast := head, head\n    for i := 0; i &lt; n; i++ {\n        fast = fast.Next\n    }\n    if fast == nil {\n        head = head.Next\n        return head\n    }\n    for fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next\n    }\n    slow.Next = slow.Next.Next\n    return head\n}\n</code></pre>"},{"location":"hot100/linkedList/LC2/","title":"LC2 - \u4e24\u6570\u76f8\u52a0","text":"AddTwoNumbers.go<pre><code>package LinkedList\n\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    carry := 0\n    for l1 != nil || l2 != nil {\n        if l1 == nil {\n            l1 = new(ListNode)\n        }\n        if l2 == nil {\n            l2 = new(ListNode)\n        }\n        sum := (l1.Val + l2.Val + carry) % 10\n        tail.Next = new(ListNode)\n        tail = tail.Next\n        tail.Val = sum\n        carry = (l1.Val + l2.Val + carry) / 10\n        l1 = l1.Next\n        l2 = l2.Next\n    }\n    if carry == 1 {\n        tail.Next = new(ListNode)\n        tail = tail.Next\n        tail.Val = 1\n    }\n    return virtualHead.Next\n}\n</code></pre> <p>\u901a\u8fc7\u521b\u5efa\u865a\u62df\u8282\u70b9\uff0c\u6a21\u62df\u4f4d\u6570\u4e0d\u8db3\u65f6\u7684\u9ad8\u4f4d\u8865\u96f6\u3002</p>"},{"location":"hot100/linkedList/LC206/","title":"LC206 - \u53cd\u8f6c\u94fe\u8868","text":"ReverseLinkedList.go<pre><code>package LinkedList\n\nfunc reverseList(head *ListNode) *ListNode {\n    if head == nil {\n        return head\n    }\n    virtualHead := new(ListNode)\n    virtualHead.Next = head\n    prev, cur, next := virtualHead, head, head.Next\n    for cur != nil {\n        next = cur.Next\n        cur.Next = prev\n        prev = cur\n        cur = next\n    }\n    head.Next = nil\n    return prev\n}\n</code></pre>"},{"location":"hot100/linkedList/LC21/","title":"LC21 - \u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u94fe\u8868","text":"MergeTwoSortedLists.go<pre><code>package LinkedList\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    cur1, cur2 := list1, list2\n    for cur1 != nil &amp;&amp; cur2 != nil {\n        if cur1.Val &lt;= cur2.Val {\n            tail.Next = cur1\n            tail = tail.Next\n            cur1 = cur1.Next\n        } else {\n            tail.Next = cur2\n            tail = tail.Next\n            cur2 = cur2.Next\n        }\n    }\n    for cur1 != nil {\n        tail.Next = cur1\n        tail = tail.Next\n        cur1 = cur1.Next\n    }\n    for cur2 != nil {\n        tail.Next = cur2\n        tail = tail.Next\n        cur2 = cur2.Next\n    }\n    return virtualHead.Next\n}\n</code></pre>"},{"location":"hot100/linkedList/LC23/","title":"LC23 - \u5408\u5e76K\u4e2a\u5347\u5e8f\u94fe\u8868","text":"MergeKSortedLists.go<pre><code>package LinkedList\n\nimport (\n    \"container/heap\"\n)\n\ntype ListNodeHeap []*ListNode\n\nfunc (h ListNodeHeap) Len() int {\n    return len(h)\n}\n\nfunc (h ListNodeHeap) Less(i, j int) bool {\n    return h[i].Val &lt; h[j].Val\n}\n\nfunc (h ListNodeHeap) Swap(i, j int) {\n    h[i], h[j] = h[j], h[i]\n}\nfunc (h *ListNodeHeap) Push(x interface{}) {\n    *h = append(*h, x.(*ListNode))\n}\n\nfunc (h *ListNodeHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * log k), \u7a7a\u95f4\u590d\u6742\u5ea6: O(k)\n// n\u8868\u793a\u8282\u70b9\u603b\u6570, k\u8868\u793a\u94fe\u8868\u4e2a\u6570\nfunc mergeKLists(lists []*ListNode) *ListNode {\n    minHeap := &amp;ListNodeHeap{}\n    heap.Init(minHeap)\n    for _, list := range lists {\n        if list != nil {\n            heap.Push(minHeap, list)\n        }\n    }\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    for minHeap.Len() &gt; 0 {\n        cur := heap.Pop(minHeap).(*ListNode)\n        tail.Next = cur\n        tail = tail.Next\n        if cur.Next != nil {\n            heap.Push(minHeap, cur.Next)\n        }\n    }\n    return virtualHead.Next\n}\n</code></pre> <p>\u672c\u9898\u4e0eLC21\u6ca1\u6709\u592a\u5927\u533a\u522b\uff0c\u552f\u4e00\u9700\u8981\u6ce8\u610f\u7684\u662f\u5806\u7ed3\u6784\u7684\u5b9e\u73b0\u3002</p>"},{"location":"hot100/linkedList/LC234/","title":"LC234 - \u56de\u6587\u94fe\u8868","text":"PalindromeLinkedList.go<pre><code>package LinkedList\n\nfunc isPalindrome(head *ListNode) bool {\n    if head == nil || head.Next == nil {\n        return true\n    }\n    // (1) \u5feb\u6162\u6307\u9488\u5bfb\u627e\u94fe\u8868\u4e2d\u70b9\n    slow, fast := head, head\n    for fast.Next != nil &amp;&amp; fast.Next.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    if fast.Next != nil {\n        fast = fast.Next\n    }\n    // (2) \u53cd\u8f6c\u540e\u9762\u7684\u94fe\u8868\n    reverseList(slow)\n    // (3) \u904d\u5386\u4e24\u4e2a\u94fe\u8868\u9010\u4e2a\u8282\u70b9\u6bd4\u8f83\n    ptr1, ptr2 := head, fast\n    for ptr1 != nil &amp;&amp; ptr2 != nil &amp;&amp; ptr1.Val == ptr2.Val {\n        ptr1 = ptr1.Next\n        ptr2 = ptr2.Next\n    }\n    var result bool\n    if ptr1 == nil || ptr2 == nil {\n        result = true\n    } else {\n        result = false\n    }\n    // (4) \u53cd\u8f6c\u56de\u540e\u9762\u7684\u94fe\u8868\n    reverseList(fast)\n    return result\n}\n</code></pre> <p><code>reverseList</code>\u51fd\u6570\u5728LC206\u4e2d\u5b9e\u73b0\u3002</p> <p>\u6b64\u5904\u4e4b\u6240\u4ee5\u9009\u62e9\u53cd\u8f6c\u540e\u9762\u7684\u94fe\u8868\u800c\u975e\u524d\u9762\u7684\u94fe\u8868\uff0c\u662f\u4e3a\u4e86\u9632\u6b62\u51fa\u73b0\u94fe\u8868\u65ad\u5f00\uff0c\u4ece\u800c\u7b80\u5316\u7f16\u7801\u96be\u5ea6\u3002</p>"},{"location":"hot100/linkedList/LC24/","title":"LC24 - \u4e24\u4e24\u4ea4\u6362\u94fe\u8868\u4e2d\u7684\u8282\u70b9","text":"SwapNodesInPairs.go<pre><code>package LinkedList\n\nfunc swapPairs(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    tail.Next = head\n    slow, fast := head, head.Next\n    for {\n        slow.Next = fast.Next\n        fast.Next = slow\n        tail.Next = fast\n        slow, fast = fast, slow\n        if fast.Next == nil || fast.Next.Next == nil {\n            break\n        }\n        tail = fast\n        slow = slow.Next.Next\n        fast = fast.Next.Next\n    }\n    return virtualHead.Next\n}\n</code></pre>"},{"location":"hot100/linkedList/LC25/","title":"LC25 - K\u4e2a\u4e00\u7ec4\u7ffb\u8f6c\u94fe\u8868","text":"ReverseNodesInKGroup.go<pre><code>package LinkedList\n\n// reverseSubLinkedList: \u53cd\u8f6c\u4ee5preStart.Next\u4e3a\u5f00\u59cb\u4f4d\u7f6e\u3001end\u4e3a\u7ed3\u675f\u4f4d\u7f6e\u7684\u5b50\u94fe\n// \u5305\u62ec\u5185\u90e8\u94fe\u8868\u7684\u53cd\u8f6c\uff0c\u4ee5\u53ca\u5916\u90e8\u94fe\u8868\u7684\u8fde\u63a5\nfunc reverseSubLinkedList(preStart, end *ListNode) {\n    endNext := end.Next\n    if preStart.Next == end {\n        return\n    }\n    cur := preStart.Next\n    var prev, next *ListNode\n    for cur != endNext {\n        next = cur.Next\n        cur.Next = prev\n        prev = cur\n        cur = next\n    }\n    preStart.Next.Next = endNext\n    preStart.Next = end\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    virtualHead := new(ListNode)\n    virtualHead.Next = head\n    preStart, end := virtualHead, virtualHead\n    for i := 0; i &lt; k; i++ {\n        end = end.Next\n    }\n    for {\n        reverseSubLinkedList(preStart, end)\n        for i := 0; i &lt; k; i++ {\n            preStart = preStart.Next\n        }\n        end = preStart\n        for i := 0; i &lt; k; i++ {\n            end = end.Next\n            if end == nil {\n                return virtualHead.Next\n            }\n        }\n    }\n}\n</code></pre> <p>\u672c\u9898\u975e\u5e38\u9002\u5408\u953b\u70bc\u94fe\u8868\u76f8\u5173\u7684\u7f16\u7801\u80fd\u529b\u3002</p>"},{"location":"hot100/matrix/LC240/","title":"LC240 - \u641c\u7d22\u4e8c\u7ef4\u77e9\u9635II","text":"SearchA2DMatrixII.go<pre><code>package Matrix\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n + m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc searchMatrix(matrix [][]int, target int) bool {\n    n, m := len(matrix), len(matrix[0])\n    if target &lt; matrix[0][0] || target &gt; matrix[n-1][m-1] {\n        return false\n    }\n    curX, curY := n-1, 0\n    for curX &gt;= 0 &amp;&amp; curX &lt; n &amp;&amp; curY &gt;= 0 &amp;&amp; curY &lt; m {\n        if matrix[curX][curY] &lt; target {\n            curY++\n        } else if matrix[curX][curY] &gt; target {\n            curX--\n        } else {\n            return true\n        }\n    }\n    return false\n}\n</code></pre> <p>\u53d6\u77e9\u9635\u5de6\u4e0b\u89d2\u5143\u7d20\u4e3a\u8d77\u59cb\u53c2\u8003\u70b9cur\uff0ccur &gt; target\u5219\u53ef\u4ee5\u5220\u9664cur\u6240\u5728\u884c\uff0ccur &lt; target\u5219\u53ef\u4ee5\u5220\u9664cur\u6240\u5728\u5217\u3002</p>"},{"location":"hot100/matrix/LC48/","title":"LC48 - \u65cb\u8f6c\u56fe\u50cf","text":"RotateImage.go<pre><code>package Matrix\n\nfunc rotate(matrix [][]int) {\n    n := len(matrix)\n    downHalf, upHalf := n/2, (n+1)/2\n    for i := 0; i &lt; downHalf; i++ {\n        for j := 0; j &lt; upHalf; j++ {\n            temp := matrix[i][j]\n            matrix[i][j] = matrix[n-1-j][i]\n            matrix[n-1-j][i] = matrix[n-1-i][n-1-j]\n            matrix[n-1-i][n-1-j] = matrix[j][n-1-i]\n            matrix[j][n-1-i] = temp\n        }\n    }\n}\n</code></pre> <p>\u6ce8\u610f\u4e24\u70b9: 1. \u5750\u6807\u53d8\u6362 2. \u77e9\u9635\u5206\u5757</p>"},{"location":"hot100/matrix/LC54/","title":"LC54 - \u87ba\u65cb\u77e9\u9635","text":"SpiralMatrix.go<pre><code>package Matrix\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n * m)\nfunc spiralOrder(matrix [][]int) []int {\n    n, m := len(matrix), len(matrix[0])\n    visited := make([][]bool, n)\n    for i := 0; i &lt; n; i++ {\n        visited[i] = make([]bool, m)\n    }\n    move := [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n    curX, curY, curMove := 0, 0, 0\n    result := make([]int, 0)\n    for k := 0; k &lt; n*m; k++ {\n        result = append(result, matrix[curX][curY])\n        visited[curX][curY] = true\n        nextX := curX + move[curMove][0]\n        nextY := curY + move[curMove][1]\n        if nextX &gt;= 0 &amp;&amp; nextX &lt; n &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; m &amp;&amp; !visited[nextX][nextY] {\n            curX, curY = nextX, nextY\n        } else {\n            curMove = (curMove + 1) % 4\n            nextX = curX + move[curMove][0]\n            nextY = curY + move[curMove][1]\n            curX, curY = nextX, nextY\n        }\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/matrix/LC73/","title":"LC73 - \u77e9\u9635\u7f6e\u96f6","text":"SetMatrixZeroes.go<pre><code>package Matrix\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc setZeroes(matrix [][]int) {\n    n, m := len(matrix), len(matrix[0])\n    // firstRow: \u7b2c\u4e00\u884c\u662f\u5426\u88ab\u5237\u62100, firstCol: \u7b2c\u4e00\u5217\u662f\u5426\u88ab\u5237\u6210\u96f6, intersection: matrix[0][0]\u662f\u5426\u4e3a0\n    firstRow, firstCol, intersection := false, false, false\n    // (1) \u904d\u5386\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\uff0c\u521d\u59cb\u5316\u4e0a\u8ff0\u4e09\u4e2a\u6807\u8bb0\n    for i := 0; i &lt; m; i++ {\n        if matrix[0][i] == 0 {\n            firstRow = true\n        }\n    }\n    for i := 0; i &lt; n; i++ {\n        if matrix[i][0] == 0 {\n            firstCol = true\n        }\n    }\n    intersection = firstRow || firstCol\n    // (2) \u904d\u5386\u53f3\u4e0b\u89d2\u77e9\u9635\uff0c\u66f4\u65b0\u884c\u5217\u4ee3\u8868\u5143\u7d20\n    for i := 1; i &lt; n; i++ {\n        for j := 1; j &lt; m; j++ {\n            if matrix[i][j] == 0 {\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n            }\n        }\n    }\n    // (3) \u4f9d\u636e\u884c\u5217\u4ee3\u8868\u5143\u7d20\u7684\u503c\uff0c\u5237\u65b0\u53f3\u4e0b\u89d2\u77e9\u9635\n    for i := 1; i &lt; n; i++ {\n        for j := 1; j &lt; m; j++ {\n            if matrix[i][0] == 0 || matrix[0][j] == 0 {\n                matrix[i][j] = 0\n            }\n        }\n    }\n    // (4) \u4f9d\u636e\u4e0a\u8ff0\u4e09\u4e2a\u6807\u8bb0\uff0c\u5237\u65b0\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\n    if intersection {\n        matrix[0][0] = 0\n    }\n    if firstRow {\n        for i := 0; i &lt; m; i++ {\n            matrix[0][i] = 0\n        }\n    }\n    if firstCol {\n        for i := 0; i &lt; n; i++ {\n            matrix[i][0] = 0\n        }\n    }\n}\n</code></pre> <p>\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230\u7684\u662f\u7a7a\u95f4\u590d\u6742\u5ea6O(n + m)\u7684\u7b97\u6cd5\uff0c\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u884c\u6807\u8bb0\u6570\u7ec4\u548c\u5217\u6807\u8bb0\u6570\u7ec4\u3002\u800c\u4e0a\u8ff0\u7a7a\u95f4\u590d\u6742\u5ea6O(1)\u7684\u7b97\u6cd5\u5c31\u662f\u5c06\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u4f5c\u4e3a\u4e86\u5217\u6807\u8bb0\u6570\u7ec4\u548c\u884c\u6807\u8bb0\u6570\u7ec4\uff0c\u5177\u4f53\u8fc7\u7a0b\u89c1\u6ce8\u91ca\u3002</p>"},{"location":"hot100/slidingWindow/LC3/","title":"LC3 - \u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32","text":"LongestSubstringWithoutRepeatingCharacters.go<pre><code>package SlidingWindow\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(\u2223\u03a3\u2223) [\u2223\u03a3\u2223\u4e3a\u5b57\u7b26\u96c6\u5927\u5c0f]\nfunc lengthOfLongestSubstring(s string) int {\n    hashSet := make(map[byte]bool)\n    lbound, rbound, result := 0, 0, 0\n    for ; rbound &lt; len(s); rbound++ {\n        if !hashSet[s[rbound]] {\n            hashSet[s[rbound]] = true\n        } else {\n            result = max(result, rbound-lbound)\n            for ; s[lbound] != s[rbound]; lbound++ {\n                hashSet[s[lbound]] = false\n            }\n            lbound++\n        }\n    }\n    result = max(result, rbound-lbound)\n    return result\n}\n</code></pre>"},{"location":"hot100/slidingWindow/LC438/","title":"LC438 - \u627e\u51fa\u5b57\u7b26\u4e32\u4e2d\u6240\u6709\u5b57\u6bcd\u5f02\u4f4d\u8bcd","text":"FindAllAnagramsInAString.go<pre><code>package SlidingWindow\n\nfunc findAnagrams(s string, p string) []int {\n    ns, np := len(s), len(p)\n    if ns &lt; np {\n        return []int{}\n    }\n    result := []int{}\n    var pCount, sCount [26]int\n    for i := 0; i &lt; np; i++ {\n        pCount[p[i]-'a']++\n        sCount[s[i]-'a']++\n    }\n    if pCount == sCount {\n        result = append(result, 0)\n    }\n    for i := np; i &lt; ns; i++ {\n        sCount[s[i]-'a']++\n        sCount[s[i-np]-'a']--\n        if pCount == sCount {\n            result = append(result, i-np+1)\n        }\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/stack/LC155/","title":"LC155 - \u6700\u5c0f\u6808","text":"MinStack.go<pre><code>package Stack\n\nimport \"math\"\n\ntype MinStack struct {\n    size int\n    data []int\n    min  []int\n}\n\nfunc Constructor() MinStack {\n    minStack := MinStack{\n        size: 0,\n        data: make([]int, 0),\n        min:  make([]int, 0),\n    }\n    return minStack\n}\n\nfunc (this *MinStack) Push(val int) {\n    var curMin int\n    if this.size == 0 {\n        curMin = math.MaxInt\n    } else {\n        curMin = this.min[this.size-1]\n    }\n    newMin := min(val, curMin)\n    this.data = append(this.data, val)\n    this.min = append(this.min, newMin)\n    this.size++\n}\n\nfunc (this *MinStack) Pop() {\n    this.data = this.data[:this.size-1]\n    this.min = this.min[:this.size-1]\n    this.size--\n}\n\nfunc (this *MinStack) Top() int {\n    return this.data[this.size-1]\n}\n\nfunc (this *MinStack) GetMin() int {\n    return this.min[this.size-1]\n}\n</code></pre>"},{"location":"hot100/stack/LC20/","title":"LC20 - \u6709\u6548\u7684\u62ec\u53f7","text":"ValidParentheses.go<pre><code>package Stack\n\n// Stack is a generic type.\ntype Stack[T any] []T\n\nfunc (s *Stack[T]) Size() int {\n    return len(*s)\n}\n\nfunc (s *Stack[T]) IsEmpty() bool {\n    return s.Size() == 0\n}\n\nfunc (s *Stack[T]) Push(val T) {\n    *s = append(*s, val)\n}\n\nfunc (s *Stack[T]) Pop() T {\n    if s.IsEmpty() {\n        var zero T\n        return zero\n    }\n    e := (*s)[s.Size()-1]\n    *s = (*s)[:s.Size()-1]\n    return e\n}\n\nfunc (s *Stack[T]) Top() T {\n    if s.IsEmpty() {\n        var zero T\n        return zero\n    }\n    return (*s)[s.Size()-1]\n}\n\nfunc isValid(s string) bool {\n    stack := new(Stack[int32])\n    for _, ch := range s {\n        if ch == '(' || ch == '[' || ch == '{' {\n            stack.Push(ch)\n        } else {\n            if stack.IsEmpty() {\n                return false\n            }\n            top := stack.Pop()\n            if !isMatch(top, ch) {\n                return false\n            }\n        }\n    }\n    return stack.IsEmpty()\n}\n\nfunc isMatch(left int32, right int32) bool {\n    if left == '(' {\n        return right == ')'\n    } else if left == '[' {\n        return right == ']'\n    } else if left == '{' {\n        return right == '}'\n    } else {\n        return false\n    }\n}\n</code></pre>"},{"location":"hot100/stack/LC394/","title":"LC394 - \u5b57\u7b26\u4e32\u89e3\u7801","text":"DecodeString.go<pre><code>package Stack\n\nimport \"strings\"\n\ntype multiRes struct {\n    multi int\n    res   string\n}\n\nfunc decodeString(s string) string {\n    stack := new(Stack[*multiRes])\n    multi, res := 0, \"\"\n    for i := 0; i &lt; len(s); i++ {\n        if s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9' {\n            multi = multi*10 + int(s[i]-'0')\n        } else if s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z' {\n            res = res + string(s[i])\n        } else if s[i] == '[' {\n            tmp := new(multiRes)\n            tmp.multi = multi\n            tmp.res = res\n            stack.Push(tmp)\n            multi, res = 0, \"\"\n        } else if s[i] == ']' {\n            tmp := stack.Pop()\n            res = tmp.res + strings.Repeat(res, tmp.multi)\n        }\n    }\n    return res\n}\n</code></pre>"},{"location":"hot100/stack/LC739/","title":"LC739 - \u6bcf\u65e5\u6e29\u5ea6","text":"DailyTemperatures.go<pre><code>package Stack\n\nfunc dailyTemperatures(temperatures []int) []int {\n    size := len(temperatures)\n    result := make([]int, size)\n    stack := new(Stack[int])\n    for i := 0; i &lt; size; i++ {\n        for !stack.IsEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.Top()] {\n            cur := stack.Pop()\n            result[cur] = i - cur\n        }\n        stack.Push(i)\n    }\n    return result\n}\n</code></pre> <p>\u5355\u8c03\u6808</p>"},{"location":"hot100/stack/LC84/","title":"LC84 - \u67f1\u72b6\u56fe\u4e2d\u6700\u5927\u7684\u77e9\u5f62","text":"LargestRectangleArea.go<pre><code>package Stack\n\nimport (\n    \"math\"\n)\n\nfunc largestRectangleArea(heights []int) int {\n    size := len(heights)\n    leftLess, rightLess := make([]int, size), make([]int, size)\n    stack := new(Stack[int])\n    // (1) \u904d\u5386\u9636\u6bb5\n    for i := 0; i &lt; size; i++ {\n        for !stack.IsEmpty() &amp;&amp; heights[i] &lt;= heights[stack.Top()] {\n            cur := stack.Pop()\n            if stack.IsEmpty() {\n                leftLess[cur] = -1\n            } else {\n                leftLess[cur] = stack.Top()\n            }\n            rightLess[cur] = i\n        }\n        stack.Push(i)\n    }\n    // (2) \u6e05\u7b97\u9636\u6bb5\n    for !stack.IsEmpty() {\n        cur := stack.Pop()\n        if stack.IsEmpty() {\n            leftLess[cur] = -1\n        } else {\n            leftLess[cur] = stack.Top()\n        }\n        rightLess[cur] = size\n    }\n    // (3) \u4fee\u6b63\u9636\u6bb5\n    for i := size - 1; i &gt;= 0; i-- {\n        if rightLess[i] &lt; size &amp;&amp; heights[i] == heights[rightLess[i]] {\n            rightLess[i] = rightLess[rightLess[i]]\n        }\n    }\n    result := math.MinInt\n    for i := 0; i &lt; size; i++ {\n        curArea := (rightLess[i] - leftLess[i] - 1) * heights[i]\n        result = max(result, curArea)\n    }\n    return result\n}\n</code></pre> <p>\u5355\u8c03\u6808\u5b8c\u6574\u6a21\u677f\u9898</p>"},{"location":"hot100/substring/LC239/","title":"LC239 - \u6ed1\u52a8\u7a97\u53e3\u6700\u5927\u503c","text":"SlidingWindowMaxium.go<pre><code>package Substring\n\nimport \"container/list\"\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(k)\nfunc maxSlidingWindow(nums []int, k int) []int {\n    result := make([]int, 0)\n    l := list.New()\n    for i := 0; i &lt; k; i++ {\n        for l.Len() &gt; 0 &amp;&amp; nums[i] &gt;= nums[l.Back().Value.(int)] {\n            l.Remove(l.Back())\n        }\n        l.PushBack(i)\n    }\n    result = append(result, nums[l.Front().Value.(int)])\n    for i := k; i &lt; len(nums); i++ {\n        if l.Front().Value.(int) == i-k {\n            l.Remove(l.Front())\n        }\n        for l.Len() &gt; 0 &amp;&amp; nums[i] &gt;= nums[l.Back().Value.(int)] {\n            l.Remove(l.Back())\n        }\n        l.PushBack(i)\n        result = append(result, nums[l.Front().Value.(int)])\n    }\n    return result\n}\n</code></pre> <p>\u5355\u8c03\u961f\u5217</p>"},{"location":"hot100/substring/LC560/","title":"LC560 - \u548c\u4e3aK\u7684\u5b50\u6570\u7ec4","text":"SubarraySumEqualsK.go<pre><code>package Substring\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc subarraySum(nums []int, k int) int {\n    nums = append([]int{0}, nums...)\n    prefixSum := make([]int, len(nums))\n    for i := 1; i &lt; len(nums); i++ {\n        prefixSum[i] = prefixSum[i-1] + nums[i]\n    }\n    // nums[i...j]\u7d2f\u52a0\u548c = prefixSum[j] - prefixSum[i - 1]\n    hashMap := make(map[int]int)\n    hashMap[0] = 1\n    result := 0\n    for i := 1; i &lt; len(nums); i++ {\n        result += hashMap[prefixSum[i]-k]\n        hashMap[prefixSum[i]]++\n    }\n    return result\n}\n</code></pre> <p>\u524d\u7f00\u548c+\u4e24\u6570\u4e4b\u548c</p>"},{"location":"hot100/substring/LC76/","title":"LC76 - \u6700\u5c0f\u8986\u76d6\u5b50\u4e32","text":"MinimumWindowSubstring.go<pre><code>package Substring\n\nimport \"math\"\n\nfunc minWindow(s string, t string) string {\n    hashMap := make(map[byte]int)\n    debt := 0\n    for i := 0; i &lt; len(t); i++ {\n        hashMap[t[i]]--\n        debt++\n    }\n    minLen := math.MaxInt\n    minPos := 0\n    for lbound, rbound := 0, 0; rbound &lt; len(s); rbound++ {\n        if hashMap[s[rbound]] &lt; 0 {\n            debt--\n        }\n        hashMap[s[rbound]]++\n        if debt == 0 {\n            for ; hashMap[s[lbound]] &gt; 0; lbound++ {\n                hashMap[s[lbound]]--\n            }\n            if rbound-lbound+1 &lt; minLen {\n                minLen = rbound - lbound + 1\n                minPos = lbound\n            }\n        }\n    }\n    if minLen == math.MaxInt {\n        return \"\"\n    }\n    return s[minPos : minPos+minLen]\n}\n</code></pre> <p>debt\u53d8\u91cf\u8bb0\u5f55\u603b\u503a\u52a1\uff0chashMap\u8bb0\u5f55\u5177\u4f53\u7684\u503a\u52a1\u8868\u3002\u7b2c\u4e00\u9636\u6bb5\u6ed1\u52a8\u7a97\u53e3\u4e0d\u65ad\u6269\u5927\uff0c\u76f4\u81f3\u603b\u503a\u52a1\u51cf\u5c0f\u4e3a0\u3002\u7b2c\u4e8c\u9636\u6bb5\u6ed1\u52a8\u7a97\u53e3\u6bcf\u6b21\u6269\u5927\u4e00\u683c(\u53f3\u8fb9\u754c\u5411\u53f3\u79fb\u52a8)\uff0c\u968f\u540e\u5c1d\u8bd5\u7f29\u5c0f(\u5de6\u8fb9\u754c\u5411\u53f3\u79fb\u52a8)\u3002</p>"}]}