{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Welcome to go-leetcode","text":"<p>A site for leetcoder with golang</p>"},{"location":"hot100/array/LC189/","title":"LC189 - \u8f6e\u8f6c\u6570\u7ec4","text":"RotateArray.go<pre><code>package Array\n\nfunc rotate(nums []int, k int) {\n    size := len(nums)\n    k = k % size\n    reverse(nums, 0, size-1)\n    reverse(nums, 0, k-1)\n    reverse(nums, k, size-1)\n}\n\nfunc reverse(nums []int, start, end int) {\n    for i, j := start, end; i &lt; j; i, j = i+1, j-1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n}\n</code></pre> <p>\u6ce8\u610f\u9700\u8981\u5148\u5bf9 k \u53d6\u6a21</p>"},{"location":"hot100/array/LC238/","title":"LC238 - \u9664\u81ea\u8eab\u5916\u6570\u7ec4\u7684\u4e58\u79ef","text":"ProductOfArrayExceptSelf.go<pre><code>package Array\n\nfunc productExceptSelf(nums []int) []int {\n    prefixSum, suffixSum := make([]int, len(nums)), make([]int, len(nums))\n    prefixSum[0], suffixSum[len(nums)-1] = nums[0], nums[len(nums)-1]\n    for i := 1; i &lt; len(nums); i++ {\n        prefixSum[i] = prefixSum[i-1] * nums[i]\n    }\n    for i := len(nums) - 2; i &gt;= 0; i-- {\n        suffixSum[i] = suffixSum[i+1] * nums[i]\n    }\n    result := make([]int, len(nums))\n    for i := 1; i &lt; len(nums)-1; i++ {\n        result[i] = prefixSum[i-1] * suffixSum[i+1]\n    }\n    result[0] = suffixSum[1]\n    result[len(nums)-1] = prefixSum[len(nums)-2]\n    return result\n}\n</code></pre>"},{"location":"hot100/array/LC41/","title":"LC41 - \u7f3a\u5931\u7684\u7b2c\u4e00\u4e2a\u6b63\u6570","text":"FirstMissingPositive.go<pre><code>package Array\n\n// \u53cc\u6307\u9488\u89e3\u6cd5, \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc firstMissingPositive(nums []int) int {\n    size := len(nums)\n    l, r := 0, size\n    // nums[0...l-1] -&gt; 1 2 3 ... l, \u8868\u793a\u5df2\u5f52\u4f4d\u7684\u90e8\u5206\n    // nums[r...size-1] -&gt; \u8868\u793a\u5783\u573e\u533a\uff0c\u540c\u65f6\u8868\u793a\u5728\u6700\u597d\u60c5\u51b5\u4e0b1-r\u8fd9\u4e9b\u6570\u5b57\u53ef\u4ee5\u5168\u90e8\u6536\u96c6\n    for l &lt; r {\n        if nums[l] == l+1 {\n            // (1) \u5df2\u5f52\u4f4d -&gt; \u7ee7\u7eed\u5224\u65ad\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\n            l++\n        } else if nums[l] &lt;= l || nums[l] &gt; r || nums[nums[l]-1] == nums[l] {\n            // (2) \u5df2\u8d8a\u754c\u6216\u76ee\u6807\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u5df2\u5f52\u4f4d -&gt; \u5c06\u5f53\u524d\u6570\u5b57\u5206\u914d\u5230\u5783\u573e\u533a\n            nums[l], nums[r-1] = nums[r-1], nums[l]\n            r--\n        } else {\n            // (3) \u4e00\u822c\u60c5\u51b5 -&gt; \u5c06\u5f53\u524d\u6570\u5b57\u4e0e\u76ee\u6807\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u8fdb\u884c\u4ea4\u6362\n            nums[l], nums[nums[l]-1] = nums[nums[l]-1], nums[l]\n        }\n    }\n    return l + 1\n}\n</code></pre> <p>MEX\u95ee\u9898\uff0c\u6ce8\u91ca\u5df2\u7ecf\u5199\u5f97\u5f88\u6e05\u695a\uff0c\u5f3a\u63a8\u5de6\u795e\u7b97\u6cd5\u8bb2\u89e3</p>"},{"location":"hot100/array/LC53/","title":"LC53 - \u6700\u5927\u5b50\u6570\u7ec4\u548c","text":"MaximumSubarray.go<pre><code>package Array\n\nimport \"math\"\n\nfunc maxSubArray(nums []int) int {\n    nums = append([]int{0}, nums...)\n    prefixSum := make([]int, len(nums))\n    for i := 1; i &lt; len(nums); i++ {\n        prefixSum[i] = prefixSum[i-1] + nums[i]\n    }\n    minPrefixSum := 0\n    maxSum := math.MinInt\n    for i := 1; i &lt; len(nums); i++ {\n        maxSum = max(maxSum, prefixSum[i]-minPrefixSum)\n        minPrefixSum = min(minPrefixSum, prefixSum[i])\n    }\n    return maxSum\n}\n</code></pre> <p>\u524d\u7f00\u548c</p>"},{"location":"hot100/array/LC56/","title":"LC56 - \u5408\u5e76\u533a\u95f4","text":"MergeIntervals.go<pre><code>package Array\n\nimport (\n    \"cmp\"\n    \"slices\"\n)\n\nfunc merge(intervals [][]int) [][]int {\n    slices.SortFunc(intervals, func(a, b []int) int {\n        return cmp.Compare(a[0], b[0])\n    })\n    result := make([][]int, 0)\n    curStart := intervals[0][0]\n    curEnd := intervals[0][1]\n    for i := 0; i &lt; len(intervals); i++ {\n        if curEnd &gt;= intervals[i][0] {\n            curEnd = max(curEnd, intervals[i][1])\n        } else {\n            result = append(result, []int{curStart, curEnd})\n            curStart = intervals[i][0]\n            curEnd = intervals[i][1]\n        }\n    }\n    result = append(result, []int{curStart, curEnd})\n    return result\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC101/","title":"LC101 - \u5bf9\u79f0\u4e8c\u53c9\u6811","text":"Symmetric.go<pre><code>package BinaryTree\n\nfunc isSymmetric(root *TreeNode) bool {\n    if root == nil {\n        return true\n    }\n    return isImage(root.Left, root.Right)\n}\n\nfunc isImage(root1, root2 *TreeNode) bool {\n    if root1 == nil &amp;&amp; root2 == nil {\n        return true\n    }\n    if root1 == nil || root2 == nil {\n        return false\n    }\n    return root1.Val == root2.Val &amp;&amp; isImage(root1.Left, root2.Right) &amp;&amp; isImage(root1.Right, root2.Left)\n}\n</code></pre> <p>\u6ce8\u610f\u672c\u9898\u4e0d\u80fd\u4f7f\u7528\u5224\u65ad\u4e2d\u5e8f\u904d\u5386\u548c\u9006\u4e2d\u5e8f\u904d\u5386\u662f\u5426\u76f8\u540c\u8fd9\u79cd\u65b9\u6cd5\u3002\u4f8b\u5982\uff0c[1,2,2,2,null,2] \u8fd9\u9897\u4e8c\u53c9\u6811\u4e24\u79cd\u65b9\u5f0f\u7684\u904d\u5386\u7ed3\u679c\u76f8\u540c\uff0c\u4f46\u5e76\u4e0d\u662f\u5bf9\u79f0\u4e8c\u53c9\u6811\u3002</p>"},{"location":"hot100/binaryTree/LC102/","title":"LC102 - \u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386","text":"LevelOrderTraversal.go.go<pre><code>package BinaryTree\n\ntype TreeNodeQueue []*TreeNode\n\nfunc (q *TreeNodeQueue) Size() int {\n    return len(*q)\n}\n\nfunc (q *TreeNodeQueue) IsEmpty() bool {\n    return len(*q) == 0\n}\n\nfunc (q *TreeNodeQueue) Enqueue(node *TreeNode) {\n    *q = append(*q, node)\n}\n\nfunc (q *TreeNodeQueue) Dequeue() *TreeNode {\n    if q.IsEmpty() {\n        return nil\n    } else {\n        node := (*q)[0]\n        *q = (*q)[1:]\n        return node\n    }\n}\n\nfunc levelOrder(root *TreeNode) [][]int {\n    result := make([][]int, 0)\n    if root == nil {\n        return result\n    }\n    q := new(TreeNodeQueue)\n    q.Enqueue(root)\n    for !q.IsEmpty() {\n        curCollection := make([]int, 0)\n        curLevelSize := q.Size()\n        for i := 0; i &lt; curLevelSize; i++ {\n            cur := q.Dequeue()\n            curCollection = append(curCollection, cur.Val)\n            if cur.Left != nil {\n                q.Enqueue(cur.Left)\n            }\n            if cur.Right != nil {\n                q.Enqueue(cur.Right)\n            }\n        }\n        result = append(result, curCollection)\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC104/","title":"LC104 - \u4e8c\u53c9\u6811\u7684\u6700\u5927\u6df1\u5ea6","text":"MaximumDepth.go<pre><code>package BinaryTree\n\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    leftRet := maxDepth(root.Left)\n    rightRet := maxDepth(root.Right)\n    return 1 + max(leftRet, rightRet)\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC105/","title":"LC105 - \u4ece\u524d\u5e8f\u548c\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\u6784\u9020\u4e8c\u53c9\u6811","text":"ConstructBinaryTree.go<pre><code>package BinaryTree\n\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n    if len(preorder) == 0 {\n        return nil\n    }\n    root := new(TreeNode)\n    root.Val = preorder[0]\n    pos := linearSearch(inorder, root.Val)\n    root.Left = buildTree(preorder[1:pos+1], inorder[:pos])\n    root.Right = buildTree(preorder[pos+1:], inorder[pos+1:])\n    return root\n}\n\nfunc linearSearch(arr []int, val int) int {\n    for i := 0; i &lt; len(arr); i++ {\n        if arr[i] == val {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC108/","title":"LC108 - \u5c06\u6709\u5e8f\u6570\u7ec4\u8f6c\u6362\u4e3a\u4e8c\u53c9\u641c\u7d22\u6811","text":"ConvertSortedArrayToBST.go<pre><code>package BinaryTree\n\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    size := len(nums)\n    if size == 0 {\n        return nil\n    }\n    root := new(TreeNode)\n    root.Val = nums[size/2]\n    root.Left = sortedArrayToBST(nums[:size/2])\n    root.Right = sortedArrayToBST(nums[size/2+1:])\n    return root\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC114/","title":"LC114 - \u4e8c\u53c9\u6811\u5c55\u5f00\u4e3a\u94fe\u8868","text":"FlattenBinaryTreeToLinkedList.go<pre><code>package BinaryTree\n\nfunc flatten(root *TreeNode) {\n    cur := root\n    for cur != nil {\n        leftChild := cur.Left\n        rightChild := cur.Right\n        if leftChild != nil {\n            rightMost := findRightMost(leftChild)\n            cur.Left = nil\n            cur.Right = leftChild\n            rightMost.Right = rightChild\n        }\n        cur = cur.Right\n    }\n}\n\nfunc findRightMost(node *TreeNode) *TreeNode {\n    var pre *TreeNode = nil\n    for node != nil {\n        pre = node\n        if node.Right != nil {\n            node = node.Right\n        } else {\n            node = node.Left\n        }\n    }\n    return pre\n}\n</code></pre> <p>\u5c06\u5de6\u5b50\u6811\u63d2\u5165\u5230\u5f53\u524d\u8282\u70b9\u548c\u53f3\u5b50\u6811\u4e4b\u95f4\uff0c\u540c\u65f6\u53f3\u5b50\u6811\u8fde\u5230\u5de6\u5b50\u6811\u6700\u53f3\u8282\u70b9\u5904\u3002</p>"},{"location":"hot100/binaryTree/LC124/","title":"LC124 - \u4e8c\u53c9\u6811\u4e2d\u7684\u6700\u5927\u8def\u5f84\u548c","text":"MaxmiumPathSum.go<pre><code>package BinaryTree\n\nimport \"math\"\n\ntype maxPathSumRet struct {\n    maxSum, maxSumWithRoot int\n}\n\nfunc maxPathSum(root *TreeNode) int {\n    return maxPathSumFunc(root).maxSum\n}\n\nfunc maxPathSumFunc(node *TreeNode) maxPathSumRet {\n    if node == nil {\n        return maxPathSumRet{\n            maxSumWithRoot: 0,\n            maxSum:         math.MinInt,\n        }\n    }\n    leftRet := maxPathSumFunc(node.Left)\n    rightRet := maxPathSumFunc(node.Right)\n    curMaxSumWithRoot := max(node.Val, node.Val+leftRet.maxSumWithRoot, node.Val+rightRet.maxSumWithRoot)\n    curMaxSum := max(leftRet.maxSum, rightRet.maxSum, curMaxSumWithRoot, node.Val+leftRet.maxSumWithRoot+rightRet.maxSumWithRoot)\n    return maxPathSumRet{\n        maxSumWithRoot: curMaxSumWithRoot,\n        maxSum:         curMaxSum,\n    }\n}\n</code></pre> <p>\u6ce8\u610f\u6811\u578bDP\u9012\u5f52\u51fa\u53e3\u8fd4\u56de\u503c\u7684\u8bbe\u7f6e</p>"},{"location":"hot100/binaryTree/LC199/","title":"LC199 - \u4e8c\u53c9\u6811\u7684\u53f3\u89c6\u56fe","text":"RightSideView.go<pre><code>package BinaryTree\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc rightSideView(root *TreeNode) []int {\n    result := make([]int, 0)\n    if root == nil {\n        return result\n    }\n    q := new(TreeNodeQueue)\n    q.Enqueue(root)\n    for !q.IsEmpty() {\n        curLevelSize := q.Size()\n        for i := 0; i &lt; curLevelSize; i++ {\n            cur := q.Dequeue()\n            if i == 0 {\n                result = append(result, cur.Val)\n            }\n            if cur.Right != nil {\n                q.Enqueue(cur.Right)\n            }\n            if cur.Left != nil {\n                q.Enqueue(cur.Left)\n            }\n        }\n    }\n    return result\n}\n</code></pre> <p>\u548cLC102\u51e0\u4e4e\u6ca1\u6709\u533a\u522b</p>"},{"location":"hot100/binaryTree/LC226/","title":"LC226 - \u7ffb\u8f6c\u4e8c\u53c9\u6811","text":"Invert.go<pre><code>package BinaryTree\n\nfunc invertTree(root *TreeNode) *TreeNode {\n    if root == nil {\n        return root\n    }\n    leftRet := invertTree(root.Left)\n    rightRet := invertTree(root.Right)\n    root.Left, root.Right = rightRet, leftRet\n    return root\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC230/","title":"LC230 - \u4e8c\u53c9\u641c\u7d22\u6811\u4e2d\u7b2cK\u5c0f\u7684\u5143\u7d20","text":"KthSmallestElementInABST.go<pre><code>package BinaryTree\n\ntype BSTWithCnt struct {\n    root *TreeNode\n    cnt  map[*TreeNode]int\n}\n\nfunc (bst *BSTWithCnt) Init(root *TreeNode) {\n    bst.root = root\n    bst.cnt = make(map[*TreeNode]int)\n    bst.count(root)\n}\n\nfunc (bst *BSTWithCnt) count(node *TreeNode) int {\n    if node == nil {\n        return 0\n    }\n    ret := bst.count(node.Left) + bst.count(node.Right) + 1\n    bst.cnt[node] = ret\n    return ret\n}\n\nfunc (bst *BSTWithCnt) Findkth(k int) int {\n    return bst.find(bst.root, k)\n}\n\nfunc (bst *BSTWithCnt) find(node *TreeNode, k int) int {\n    leftCnt := bst.cnt[node.Left]\n    if leftCnt == k-1 {\n        return node.Val\n    } else if leftCnt &lt; k-1 {\n        return bst.find(node.Right, k-leftCnt-1)\n    } else {\n        return bst.find(node.Left, k)\n    }\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(h), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n// h\u8868\u793aBST\u7684\u9ad8\u5ea6, n\u8868\u793aBST\u8282\u70b9\u603b\u6570\nfunc kthSmallest(root *TreeNode, k int) int {\n    bst := new(BSTWithCnt)\n    bst.Init(root)\n    return bst.Findkth(k)\n}\n</code></pre> <p>\u4e2d\u5e8f\u904d\u5386\u7684\u65b9\u6cd5\u5c31\u4e0d\u8bf4\u4e86\uff0c\u5176\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(h + k)\u3002\u5f53\u9700\u8981\u9891\u7e41\u67e5\u627e\u7b2cK\u5c0f\u7684\u5143\u7d20\u65f6\uff0c\u901a\u8fc7\u751f\u6210\u9884\u5904\u7406\u7ed3\u6784<code>BSTWithCnt</code>(\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n))\uff0c\u53ef\u4ee5\u5c06\u6bcf\u6b21\u67e5\u627e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u81f3O(h)\u3002</p>"},{"location":"hot100/binaryTree/LC236/","title":"LC236 - \u4e8c\u53c9\u6811\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148","text":"LowestCommonAncestor.go<pre><code>package BinaryTree\n\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    if root == nil || root == p || root == q {\n        return root\n    }\n    leftRet := lowestCommonAncestor(root.Left, p, q)\n    rightRet := lowestCommonAncestor(root.Right, p, q)\n    if leftRet != nil &amp;&amp; rightRet != nil {\n        return root\n    }\n    if leftRet == nil &amp;&amp; rightRet == nil {\n        return nil\n    }\n    if leftRet != nil {\n        return leftRet\n    } else {\n        return rightRet\n    }\n}\n</code></pre> <p>LCA\u95ee\u9898\uff0c\u76f4\u63a5\u8bb0\u6a21\u677f\u3002</p>"},{"location":"hot100/binaryTree/LC437/","title":"LC437 - \u8def\u5f84\u603b\u548c III","text":"PathSumIII.go<pre><code>package BinaryTree\n\nfunc pathSum(root *TreeNode, targetSum int) int {\n    hashMap := make(map[int]int)\n    hashMap[0] = 1\n    cnt := 0\n    var dfs func(*TreeNode, int)\n    dfs = func(node *TreeNode, sum int) {\n        if node == nil {\n            return\n        }\n        sum += node.Val\n        cnt += hashMap[sum-targetSum]\n        hashMap[sum]++\n        dfs(node.Left, sum)\n        dfs(node.Right, sum)\n        hashMap[sum]--\n    }\n    dfs(root, 0)\n    return cnt\n}\n</code></pre> <p>\u6839\u636e\u9898\u76ee\u5bf9\u8def\u5f84\u7684\u5b9a\u4e49\uff0c\u672c\u9898\u5b9e\u8d28\u4e0a\u662f\u6811\u7248\u7684LC560\u3002</p> <p>\u9700\u8981\u7279\u522b\u6ce8\u610f\u7684\u662f\u6b64\u5904\u5fc5\u987b\u5728DFS\u7684\u8fc7\u7a0b\u4e2d\u5bf9\u54c8\u5e0c\u8868\u8fdb\u884c\u56de\u6eaf\u3002</p>"},{"location":"hot100/binaryTree/LC543/","title":"LC543 - \u4e8c\u53c9\u6811\u7684\u76f4\u5f84","text":"Diameter.go<pre><code>package BinaryTree\n\ntype diameterRet struct {\n    height, diameter int\n}\n\nfunc diameterOfBinaryTree(root *TreeNode) int {\n    return diameterFunc(root).diameter\n}\n\nfunc diameterFunc(root *TreeNode) diameterRet {\n    if root == nil {\n        return diameterRet{\n            height:   0,\n            diameter: 0,\n        }\n    }\n    leftRet := diameterFunc(root.Left)\n    rightRet := diameterFunc(root.Right)\n    return diameterRet{\n        height:   max(leftRet.height, rightRet.height) + 1,\n        diameter: max(leftRet.diameter, rightRet.diameter, leftRet.height+rightRet.height),\n    }\n}\n</code></pre> <p>\u6811\u578bDP</p>"},{"location":"hot100/binaryTree/LC94/","title":"LC94 - \u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u904d\u5386","text":"InorderTraversal.go<pre><code>package BinaryTree\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc inorderTraversal(root *TreeNode) []int {\n    return inorderTraversal2(root)\n}\n\n// \u9012\u5f52\u5b9e\u73b0\nfunc inorderTraversal1(root *TreeNode) []int {\n    ret := make([]int, 0)\n    if root == nil {\n        return ret\n    }\n    leftRet := inorderTraversal1(root.Left)\n    rightRet := inorderTraversal1(root.Right)\n    ret = append(ret, leftRet...)\n    ret = append(ret, root.Val)\n    ret = append(ret, rightRet...)\n    return ret\n}\n\ntype TreeNodeStack []*TreeNode\n\nfunc (s *TreeNodeStack) Size() int {\n    return len(*s)\n}\n\nfunc (s *TreeNodeStack) IsEmpty() bool {\n    return len(*s) == 0\n}\n\nfunc (s *TreeNodeStack) Push(node *TreeNode) {\n    *s = append(*s, node)\n}\n\nfunc (s *TreeNodeStack) Pop() *TreeNode {\n    if s.IsEmpty() {\n        return nil\n    } else {\n        node := (*s)[s.Size()-1]\n        *s = (*s)[:s.Size()-1]\n        return node\n    }\n}\n\n// \u8fed\u4ee3\u5b9e\u73b0\nfunc inorderTraversal2(root *TreeNode) []int {\n    ret := make([]int, 0)\n    if root == nil {\n        return ret\n    }\n    s := new(TreeNodeStack)\n    cur := root\n    for cur != nil {\n        s.Push(cur)\n        cur = cur.Left\n    }\n    for !s.IsEmpty() {\n        node := s.Pop()\n        ret = append(ret, node.Val)\n        cur = node.Right\n        for cur != nil {\n            s.Push(cur)\n            cur = cur.Left\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"hot100/binaryTree/LC98/","title":"LC98 - \u9a8c\u8bc1\u4e8c\u53c9\u641c\u7d22\u6811","text":"ValidateBST.go<pre><code>package BinaryTree\n\nimport \"math\"\n\ntype isBSTRet struct {\n    isBST          bool\n    maxVal, minVal int\n}\n\nfunc isValidBST(root *TreeNode) bool {\n    return isBSTFunc(root).isBST\n}\n\nfunc isBSTFunc(root *TreeNode) isBSTRet {\n    if root == nil {\n        return isBSTRet{\n            isBST:  true,\n            maxVal: math.MinInt,\n            minVal: math.MaxInt,\n        }\n    }\n    leftRet := isBSTFunc(root.Left)\n    rightRet := isBSTFunc(root.Right)\n    return isBSTRet{\n        isBST:  leftRet.isBST &amp;&amp; rightRet.isBST &amp;&amp; root.Val &gt; leftRet.maxVal &amp;&amp; root.Val &lt; rightRet.minVal,\n        maxVal: max(leftRet.maxVal, rightRet.maxVal, root.Val),\n        minVal: min(leftRet.minVal, rightRet.minVal, root.Val),\n    }\n}\n</code></pre>"},{"location":"hot100/doublePointers/LC11/","title":"LC11 - \u76db\u6c34\u6700\u591a\u7684\u5bb9\u5668","text":"ContainerWithMostWater.go<pre><code>package DoublePointers\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc maxArea(height []int) int {\n    left, right := 0, len(height)-1\n    result := (right - left) * min(height[left], height[right])\n    for left &lt; right {\n        if height[left] &lt;= height[right] {\n            tmp := height[left]\n            for left &lt; right &amp;&amp; height[left] &lt;= tmp {\n                left++\n            }\n        } else {\n            tmp := height[right]\n            for left &lt; right &amp;&amp; height[right] &lt;= tmp {\n                right--\n            }\n        }\n        result = max(result, (right-left)*min(height[left], height[right]))\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/doublePointers/LC15/","title":"LC15 - \u4e09\u6570\u4e4b\u548c","text":"ThreeSum.go<pre><code>package DoublePointers\n\nimport \"slices\"\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n^2), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc threeSum(nums []int) [][]int {\n    slices.Sort(nums)\n    result := make([][]int, 0)\n    for i := 0; i &lt; len(nums)-2; i = next(i, nums) {\n        j, k := i+1, len(nums)-1\n        for j &lt; k {\n            if nums[i]+nums[j]+nums[k] == 0 {\n                result = append(result, []int{nums[i], nums[j], nums[k]})\n                j = next(j, nums)\n                k = prev(k, nums)\n            } else if nums[i]+nums[j]+nums[k] &lt; 0 {\n                j = next(j, nums)\n            } else {\n                k = prev(k, nums)\n            }\n        }\n    }\n    return result\n}\n\nfunc next(i int, nums []int) int {\n    length := len(nums)\n    for ; i+1 &lt; length &amp;&amp; nums[i] == nums[i+1]; i++ {\n    }\n    return i + 1\n}\n\nfunc prev(i int, nums []int) int {\n    for ; i-1 &gt;= 0 &amp;&amp; nums[i] == nums[i-1]; i-- {\n    }\n    return i - 1\n}\n</code></pre> <p>\u672c\u9898\u4e0eLC1\u7684\u6700\u672c\u8d28\u533a\u522b\u5728\u4e8e\u53ea\u9700\u8fd4\u56de\u6570\u503c\u800c\u4e0d\u7528\u539f\u59cb\u6570\u7ec4\u7684\u4e0b\u6807\uff0c\u56e0\u6b64\u975e\u5e38\u9002\u5408\u4f7f\u7528\u53cc\u6307\u9488\u3002</p> <p>\u4e3a\u4e86\u5b9e\u73b0\u5bf9\u7ed3\u679c\u7684\u53bb\u91cd\uff0c\u9700\u8981\u5b9e\u73b0<code>next</code>\u51fd\u6570\u548c<code>prev</code>\u51fd\u6570\u4ee5\u53d6\u4ee3\u539f\u672c\u7684--\u548c++\u3002</p>"},{"location":"hot100/doublePointers/LC283/","title":"LC283 - \u79fb\u52a8\u96f6","text":"MoveZeroes.go<pre><code>package DoublePointers\n\nfunc moveZeroes(nums []int) {\n    moveZeroes2(nums)\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n^2), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc moveZeroes1(nums []int) {\n    left, right := 0, len(nums)-1\n    for left &lt;= right {\n        if nums[left] == 0 {\n            moveToEnd(nums, left, right)\n            right--\n        } else {\n            left++\n        }\n    }\n}\n\nfunc moveToEnd(nums []int, left int, right int) {\n    tmp := nums[left]\n    for i := left; i &lt; right; i++ {\n        nums[i] = nums[i+1]\n    }\n    nums[right] = tmp\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc moveZeroes2(nums []int) {\n    left, right := 0, 0\n    for right &lt; len(nums) {\n        if nums[right] != 0 {\n            nums[left], nums[right] = nums[right], nums[left]\n            left++\n        }\n        right++\n    }\n}\n</code></pre> <p><code>moveZeroes1</code>\u65b9\u6cd5\u4e2d\uff0c\u53f3\u4fa7\u6307\u9488\u7ef4\u62a4\u96f6\u533a\uff0c\u7531\u4e8e\u9898\u76ee\u8981\u6c42\u6240\u6709\u975e\u96f6\u6570\u503c\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4fdd\u6301\u4e0d\u53d8\uff0c\u56e0\u6b64\u4e0d\u80fd\u7b80\u5355\u4ea4\u6362\u5de6\u53f3\u6307\u9488\u6307\u5411\u7684\u6570\u5b57\uff0c\u5fc5\u987b\u8fdb\u884c\u6574\u4f53\u7684\u632a\u52a8\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n^2)\u3002</p> <p><code>moveZeroes2</code>\u65b9\u6cd5\u4e2d\uff0c\u5de6\u4fa7\u6307\u9488\u7ef4\u62a4\u975e\u96f6\u533a\uff0c\u4ea4\u6362\u64cd\u4f5c\u53ef\u4ee5\u7ef4\u6301\u6240\u6709\u975e\u96f6\u6570\u503c\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4fdd\u6301\u4e0d\u53d8\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n)\u3002</p>"},{"location":"hot100/doublePointers/LC42/","title":"LC42 - \u63a5\u96e8\u6c34","text":"TrappingRainWater.go<pre><code>package DoublePointers\n\nfunc trap(height []int) int {\n    return trap1(height)\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc trap1(height []int) int {\n    size := len(height)\n    lmax := make([]int, size)\n    lmax[0] = height[0]\n    for i := 1; i &lt; size; i++ {\n        lmax[i] = max(lmax[i-1], height[i])\n    }\n    rmax := make([]int, size)\n    rmax[size-1] = height[size-1]\n    for j := size - 2; j &gt;= 0; j-- {\n        rmax[j] = max(rmax[j+1], height[j])\n    }\n    result := 0\n    for i := 1; i &lt; size-1; i++ {\n        limit := min(lmax[i-1], rmax[i+1])\n        curVolume := max(0, limit-height[i])\n        result += curVolume\n    }\n    return result\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc trap2(height []int) int {\n    left, right := 1, len(height)-2\n    lmax, rmax := height[0], height[len(height)-1]\n    result := 0\n    for left &lt;= right {\n        if lmax &lt;= rmax {\n            result += max(0, lmax-height[left])\n            lmax = max(lmax, height[left])\n            left++\n        } else {\n            result += max(0, rmax-height[right])\n            rmax = max(rmax, height[right])\n            right--\n        }\n    }\n    return result\n}\n</code></pre> <p>\u6bcf\u4e2a\u683c\u5b50\u7684\u6c34\u4f4d\u7ebf\u53d6\u51b3\u4e8e\u5de6\u4fa7\u6700\u5927\u9ad8\u5ea6\u548c\u53f3\u4fa7\u6700\u5927\u9ad8\u5ea6\u7684\u8f83\u5c0f\u503c\u3002</p>"},{"location":"hot100/hashTable/LC1/","title":"LC1 - \u4e24\u6570\u4e4b\u548c","text":"TwoSum.go<pre><code>package HashTable\n\nimport (\n    \"cmp\"\n    \"slices\"\n)\n\nfunc twoSum(nums []int, target int) []int {\n    return twoSum1(nums, target)\n}\n\ntype indexedNum struct {\n    Value int\n    Index int\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * log n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc twoSum1(nums []int, target int) []int {\n    indexedNums := make([]indexedNum, len(nums))\n    for i, num := range nums {\n        indexedNums[i] = indexedNum{num, i}\n    }\n    slices.SortFunc(indexedNums, func(a, b indexedNum) int {\n        return cmp.Compare(a.Value, b.Value)\n    })\n    left, right := 0, len(nums)-1\n    for left &lt; right {\n        sum := indexedNums[left].Value + indexedNums[right].Value\n        if sum == target {\n            return []int{indexedNums[left].Index, indexedNums[right].Index}\n        } else if sum &gt; target {\n            right--\n        } else {\n            left++\n        }\n    }\n    return nil\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc twoSum2(nums []int, target int) []int {\n    hashTable := make(map[int]int)\n    for index2, num2 := range nums {\n        num1 := target - num2\n        if index1, ok := hashTable[num1]; ok {\n            return []int{index1, index2}\n        } else {\n            hashTable[num2] = index2\n        }\n    }\n    return nil\n}\n</code></pre> <p>\u7b2c\u4e00\u53cd\u5e94\u662f\u6392\u5e8f\u540e\u53cc\u6307\u9488\uff0c\u4f46\u7531\u4e8e\u9700\u8981\u8fd4\u56de\u539f\u6570\u7ec4\u7d22\u5f15\u800c\u975e\u6570\u503c\uff0c\u56e0\u6b64\u5fc5\u987b\u501f\u52a9\u8f85\u52a9\u6570\u7ec4\u3002</p>"},{"location":"hot100/hashTable/LC128/","title":"LC128 - \u6700\u957f\u8fde\u7eed\u5e8f\u5217","text":"LongestConsecutiveSequence.go<pre><code>package HashTable\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc longestConsecutive(nums []int) int {\n    hashSet := make(map[int]bool)\n    for _, num := range nums {\n        hashSet[num] = true\n    }\n    result := 0\n    for num := range hashSet {\n        if hashSet[num-1] {\n            continue\n        }\n        tmp := num\n        for hashSet[tmp] {\n            tmp++\n        }\n        result = max(result, tmp-num)\n    }\n    return result\n}\n</code></pre> <p>\u6700\u5173\u952e\u7684\u90e8\u5206\u5c31\u662f11-13\u884c\uff0c\u6b63\u662f\u6709\u4e86\u8fd9\u91cc\u7684\u526a\u679d\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u624d\u5f97\u4ee5\u63a7\u5236\u5728O(n)\u3002</p> <p>\u9664\u6b64\u4ee5\u5916\u5fc5\u987b\u904d\u5386\u54c8\u5e0c\u8868\u800c\u975e\u539f\u59cb\u6570\u7ec4\uff0c\u56e0\u4e3a\u539f\u59cb\u6570\u636e\u4e2d\u53ef\u80fd\u5b58\u5728\u91cd\u590d\u6570\u5b57\uff0c\u5728\u7279\u5b9a\u60c5\u51b5\u4e0b(\u5982: 1111...2345...)\u4f1a\u4f7f\u65f6\u95f4\u590d\u6742\u5ea6\u8fbe\u5230O(n^2)\u89c4\u6a21\u3002</p>"},{"location":"hot100/hashTable/LC49/","title":"LC49 - \u5b57\u6bcd\u5f02\u4f4d\u8bcd\u5206\u7ec4","text":"GroupAnagrams.go<pre><code>package HashTable\n\nimport \"slices\"\n\nfunc groupAnagrams(strs []string) [][]string {\n    hashTable := make(map[string][]string)\n    for _, str := range strs {\n        strByte := []byte(str)\n        slices.Sort(strByte)\n        s := string(strByte)\n        hashTable[s] = append(hashTable[s], str)\n    }\n    result := make([][]string, 0)\n    for _, group := range hashTable {\n        result = append(result, group)\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/linkedList/LC138/","title":"LC138 - \u968f\u673a\u94fe\u8868\u7684\u590d\u5236","text":"CopyListWithRandomPointer.go<pre><code>package LinkedList\n\ntype Node struct {\n    Val    int\n    Next   *Node\n    Random *Node\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc copyRandomList(head *Node) *Node {\n    if head == nil {\n        return nil\n    }\n    for cur := head; cur != nil; cur = cur.Next.Next {\n        copyNode := new(Node)\n        copyNode.Val = cur.Val\n        copyNode.Next = cur.Next\n        cur.Next = copyNode\n    }\n    for cur := head; cur != nil; cur = cur.Next.Next {\n        copyNode := cur.Next\n        if cur.Random != nil {\n            copyNode.Random = cur.Random.Next\n        } else {\n            copyNode.Random = nil\n        }\n    }\n    copyHead := head.Next\n    for cur := head; cur != nil; cur = cur.Next {\n        copyNode := cur.Next\n        cur.Next = copyNode.Next\n        if copyNode.Next != nil {\n            copyNode.Next = copyNode.Next.Next\n        } else {\n            copyNode.Next = nil\n        }\n    }\n    return copyHead\n}\n</code></pre>"},{"location":"hot100/linkedList/LC141/","title":"LC141 - \u73af\u5f62\u94fe\u8868","text":"LinkedListCycle.go<pre><code>package LinkedList\n\nfunc hasCycle(head *ListNode) bool {\n    slow, fast := head, head\n    for fast != nil &amp;&amp; fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            return true\n        }\n    }\n    return false\n}\n</code></pre> <p>\u5feb\u6162\u6307\u9488\u3002\u82e5\u94fe\u8868\u6709\u73af\uff0c\u5219\u5feb\u6162\u6307\u9488\u5fc5\u7136\u4f1a\u5728\u73af\u4e0a\u91cd\u65b0\u76f8\u9047\uff1b\u5426\u5219\u5fc5\u7136\u4e0d\u4f1a\u91cd\u65b0\u76f8\u9047\u3002</p>"},{"location":"hot100/linkedList/LC142/","title":"LC142 - \u73af\u5f62\u94fe\u8868II","text":"LinkedListCycle.go<pre><code>func detectCycle(head *ListNode) *ListNode {\n    slow, fast := head, head\n    for fast != nil &amp;&amp; fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            break\n        }\n    }\n    if fast == nil || fast.Next == nil {\n        return nil\n    }\n    fast = head\n    for {\n        if slow == fast {\n            return slow\n        }\n        slow = slow.Next\n        fast = fast.Next\n    }\n}\n</code></pre> <p>\u5feb\u6162\u6307\u9488\u3002\u82e5\u94fe\u8868\u6709\u73af\uff0c\u5219\u5feb\u6162\u6307\u9488\u5fc5\u7136\u4f1a\u5728\u73af\u4e0a\u91cd\u65b0\u76f8\u9047\uff0c\u6b64\u65f6\u5c06\u5feb\u6307\u9488\u91cd\u65b0\u5f52\u4f4d\u81f3\u5934\u8282\u70b9\uff0c\u5feb\u6162\u6307\u9488\u6bcf\u6b21\u8d70\u4e00\u6b65\uff0c\u76f8\u9047\u4f4d\u7f6e\u5373\u4e3a\u5165\u73af\u8282\u70b9\u3002</p>"},{"location":"hot100/linkedList/LC146/","title":"LC146 - LRU\u7f13\u5b58","text":"LRUCache.go<pre><code>package LinkedList\n\ntype LRUNode struct {\n    key, val   int\n    prev, next *LRUNode\n}\ntype LRUCache struct {\n    size, capacity int\n    hashMap        map[int]*LRUNode\n    virtualHead    *LRUNode\n    virtualTail    *LRUNode\n}\n\nfunc Constructor(capacity int) LRUCache {\n    cache := LRUCache{\n        size:        0,\n        capacity:    capacity,\n        hashMap:     make(map[int]*LRUNode),\n        virtualHead: new(LRUNode),\n        virtualTail: new(LRUNode),\n    }\n    cache.virtualHead.next = cache.virtualTail\n    cache.virtualTail.prev = cache.virtualHead\n    return cache\n}\n\n// Get \u5355\u6b21\u64cd\u4f5c\u65f6\u95f4\u590d\u6742\u5ea6: O(1)\nfunc (this *LRUCache) Get(key int) int {\n    if node, ok := this.hashMap[key]; !ok {\n        return -1\n    } else {\n        ret := node.val\n        this.moveToHead(node)\n        return ret\n    }\n}\n\n// Put \u5355\u6b21\u64cd\u4f5c\u65f6\u95f4\u590d\u6742\u5ea6: O(1)\nfunc (this *LRUCache) Put(key int, value int) {\n    if node, ok := this.hashMap[key]; ok {\n        node.val = value\n        this.moveToHead(node)\n    } else {\n        node = new(LRUNode)\n        node.key = key\n        node.val = value\n        this.hashMap[key] = node\n        this.insertToHead(node)\n        if this.size == this.capacity {\n            last := this.virtualTail.prev\n            delete(this.hashMap, last.key)\n            this.removeAtTail()\n        } else {\n            this.size++\n        }\n    }\n}\n\nfunc (this *LRUCache) moveToHead(node *LRUNode) {\n    node.prev.next = node.next\n    node.next.prev = node.prev\n    first := this.virtualHead.next\n    this.virtualHead.next = node\n    node.prev = this.virtualHead\n    node.next = first\n    first.prev = node\n}\n\nfunc (this *LRUCache) insertToHead(node *LRUNode) {\n    first := this.virtualHead.next\n    this.virtualHead.next = node\n    node.prev = this.virtualHead\n    node.next = first\n    first.prev = node\n}\n\nfunc (this *LRUCache) removeAtTail() {\n    lastPrev := this.virtualTail.prev.prev\n    lastPrev.next = this.virtualTail\n    this.virtualTail.prev = lastPrev\n}\n</code></pre> <p>\u636e\u8bf4\u662f\u5927\u5382\u624b\u6495\u6700\u9ad8\u9891\u8003\u9898\u3002</p> <p>\u54c8\u5e0c\u8868 + \u53cc\u5411\u94fe\u8868\u3002</p>"},{"location":"hot100/linkedList/LC148/","title":"LC148 - \u6392\u5e8f\u94fe\u8868","text":"SortList.go<pre><code>package LinkedList\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * log n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(log n)\nfunc sortList(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    slow, fast := head, head\n    for fast.Next != nil &amp;&amp; fast.Next.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    fast = slow.Next\n    slow.Next = nil\n    head1 := sortList(head)\n    head2 := sortList(fast)\n    newHead := mergeTwoLists(head1, head2)\n    return newHead\n}\n</code></pre> <p><code>mergeTwoLists</code>\u51fd\u6570\u5728LC21\u4e2d\u5b9e\u73b0\u3002</p> <p>\u5f52\u5e76\u6392\u5e8f\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a\u9012\u5f52\u6df1\u5ea6O(log n)\u3002</p>"},{"location":"hot100/linkedList/LC160/","title":"LC160 - \u76f8\u4ea4\u94fe\u8868","text":"IntersectionOfTwoLinkedLists.go<pre><code>package LinkedList\n\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    curA, curB := headA, headB\n    lenA, lenB := 0, 0\n    for ; curA != nil; curA = curA.Next {\n        lenA++\n    }\n    for ; curB != nil; curB = curB.Next {\n        lenB++\n    }\n    curA, curB = headA, headB\n    if lenA &gt; lenB {\n        for i := 0; i &lt; lenA-lenB; i++ {\n            curA = curA.Next\n        }\n    } else {\n        for i := 0; i &lt; lenB-lenA; i++ {\n            curB = curB.Next\n        }\n    }\n    for curA != curB {\n        curA = curA.Next\n        curB = curB.Next\n    }\n    return curA\n}\n</code></pre>"},{"location":"hot100/linkedList/LC19/","title":"LC19 - \u5220\u9664\u94fe\u8868\u7684\u5012\u6570\u7b2cN\u4e2a\u8282\u70b9","text":"RemoveNthNodeFromEndOfList.go<pre><code>package LinkedList\n\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    slow, fast := head, head\n    for i := 0; i &lt; n; i++ {\n        fast = fast.Next\n    }\n    if fast == nil {\n        head = head.Next\n        return head\n    }\n    for fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next\n    }\n    slow.Next = slow.Next.Next\n    return head\n}\n</code></pre>"},{"location":"hot100/linkedList/LC2/","title":"LC2 - \u4e24\u6570\u76f8\u52a0","text":"AddTwoNumbers.go<pre><code>package LinkedList\n\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    carry := 0\n    for l1 != nil || l2 != nil {\n        if l1 == nil {\n            l1 = new(ListNode)\n        }\n        if l2 == nil {\n            l2 = new(ListNode)\n        }\n        sum := (l1.Val + l2.Val + carry) % 10\n        tail.Next = new(ListNode)\n        tail = tail.Next\n        tail.Val = sum\n        carry = (l1.Val + l2.Val + carry) / 10\n        l1 = l1.Next\n        l2 = l2.Next\n    }\n    if carry == 1 {\n        tail.Next = new(ListNode)\n        tail = tail.Next\n        tail.Val = 1\n    }\n    return virtualHead.Next\n}\n</code></pre> <p>\u901a\u8fc7\u521b\u5efa\u865a\u62df\u8282\u70b9\uff0c\u6a21\u62df\u4f4d\u6570\u4e0d\u8db3\u65f6\u7684\u9ad8\u4f4d\u8865\u96f6\u3002</p>"},{"location":"hot100/linkedList/LC206/","title":"LC206 - \u53cd\u8f6c\u94fe\u8868","text":"ReverseLinkedList.go<pre><code>package LinkedList\n\nfunc reverseList(head *ListNode) *ListNode {\n    if head == nil {\n        return head\n    }\n    virtualHead := new(ListNode)\n    virtualHead.Next = head\n    prev, cur, next := virtualHead, head, head.Next\n    for cur != nil {\n        next = cur.Next\n        cur.Next = prev\n        prev = cur\n        cur = next\n    }\n    head.Next = nil\n    return prev\n}\n</code></pre>"},{"location":"hot100/linkedList/LC21/","title":"LC21 - \u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u94fe\u8868","text":"MergeTwoSortedLists.go<pre><code>package LinkedList\n\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    cur1, cur2 := list1, list2\n    for cur1 != nil &amp;&amp; cur2 != nil {\n        if cur1.Val &lt;= cur2.Val {\n            tail.Next = cur1\n            tail = tail.Next\n            cur1 = cur1.Next\n        } else {\n            tail.Next = cur2\n            tail = tail.Next\n            cur2 = cur2.Next\n        }\n    }\n    for cur1 != nil {\n        tail.Next = cur1\n        tail = tail.Next\n        cur1 = cur1.Next\n    }\n    for cur2 != nil {\n        tail.Next = cur2\n        tail = tail.Next\n        cur2 = cur2.Next\n    }\n    return virtualHead.Next\n}\n</code></pre>"},{"location":"hot100/linkedList/LC23/","title":"LC23 - \u5408\u5e76K\u4e2a\u5347\u5e8f\u94fe\u8868","text":"MergeKSortedLists.go<pre><code>package LinkedList\n\nimport (\n    \"container/heap\"\n)\n\ntype ListNodeHeap []*ListNode\n\nfunc (h ListNodeHeap) Len() int {\n    return len(h)\n}\n\nfunc (h ListNodeHeap) Less(i, j int) bool {\n    return h[i].Val &lt; h[j].Val\n}\n\nfunc (h ListNodeHeap) Swap(i, j int) {\n    h[i], h[j] = h[j], h[i]\n}\nfunc (h *ListNodeHeap) Push(x interface{}) {\n    *h = append(*h, x.(*ListNode))\n}\n\nfunc (h *ListNodeHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * log k), \u7a7a\u95f4\u590d\u6742\u5ea6: O(k)\n// n\u8868\u793a\u8282\u70b9\u603b\u6570, k\u8868\u793a\u94fe\u8868\u4e2a\u6570\nfunc mergeKLists(lists []*ListNode) *ListNode {\n    minHeap := &amp;ListNodeHeap{}\n    heap.Init(minHeap)\n    for _, list := range lists {\n        if list != nil {\n            heap.Push(minHeap, list)\n        }\n    }\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    for minHeap.Len() &gt; 0 {\n        cur := heap.Pop(minHeap).(*ListNode)\n        tail.Next = cur\n        tail = tail.Next\n        if cur.Next != nil {\n            heap.Push(minHeap, cur.Next)\n        }\n    }\n    return virtualHead.Next\n}\n</code></pre> <p>\u672c\u9898\u4e0eLC21\u6ca1\u6709\u592a\u5927\u533a\u522b\uff0c\u552f\u4e00\u9700\u8981\u6ce8\u610f\u7684\u662f\u5806\u7ed3\u6784\u7684\u5b9e\u73b0\u3002</p>"},{"location":"hot100/linkedList/LC234/","title":"LC234 - \u56de\u6587\u94fe\u8868","text":"PalindromeLinkedList.go<pre><code>package LinkedList\n\nfunc isPalindrome(head *ListNode) bool {\n    if head == nil || head.Next == nil {\n        return true\n    }\n    // (1) \u5feb\u6162\u6307\u9488\u5bfb\u627e\u94fe\u8868\u4e2d\u70b9\n    slow, fast := head, head\n    for fast.Next != nil &amp;&amp; fast.Next.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n    }\n    if fast.Next != nil {\n        fast = fast.Next\n    }\n    // (2) \u53cd\u8f6c\u540e\u9762\u7684\u94fe\u8868\n    reverseList(slow)\n    // (3) \u904d\u5386\u4e24\u4e2a\u94fe\u8868\u9010\u4e2a\u8282\u70b9\u6bd4\u8f83\n    ptr1, ptr2 := head, fast\n    for ptr1 != nil &amp;&amp; ptr2 != nil &amp;&amp; ptr1.Val == ptr2.Val {\n        ptr1 = ptr1.Next\n        ptr2 = ptr2.Next\n    }\n    var result bool\n    if ptr1 == nil || ptr2 == nil {\n        result = true\n    } else {\n        result = false\n    }\n    // (4) \u53cd\u8f6c\u56de\u540e\u9762\u7684\u94fe\u8868\n    reverseList(fast)\n    return result\n}\n</code></pre> <p><code>reverseList</code>\u51fd\u6570\u5728LC206\u4e2d\u5b9e\u73b0\u3002</p> <p>\u6b64\u5904\u4e4b\u6240\u4ee5\u9009\u62e9\u53cd\u8f6c\u540e\u9762\u7684\u94fe\u8868\u800c\u975e\u524d\u9762\u7684\u94fe\u8868\uff0c\u662f\u4e3a\u4e86\u9632\u6b62\u51fa\u73b0\u94fe\u8868\u65ad\u5f00\uff0c\u4ece\u800c\u7b80\u5316\u7f16\u7801\u96be\u5ea6\u3002</p>"},{"location":"hot100/linkedList/LC24/","title":"LC24 - \u4e24\u4e24\u4ea4\u6362\u94fe\u8868\u4e2d\u7684\u8282\u70b9","text":"SwapNodesInPairs.go<pre><code>package LinkedList\n\nfunc swapPairs(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    virtualHead := new(ListNode)\n    tail := virtualHead\n    tail.Next = head\n    slow, fast := head, head.Next\n    for {\n        slow.Next = fast.Next\n        fast.Next = slow\n        tail.Next = fast\n        slow, fast = fast, slow\n        if fast.Next == nil || fast.Next.Next == nil {\n            break\n        }\n        tail = fast\n        slow = slow.Next.Next\n        fast = fast.Next.Next\n    }\n    return virtualHead.Next\n}\n</code></pre>"},{"location":"hot100/linkedList/LC25/","title":"LC25 - K\u4e2a\u4e00\u7ec4\u7ffb\u8f6c\u94fe\u8868","text":"ReverseNodesInKGroup.go<pre><code>package LinkedList\n\n// reverseSubLinkedList: \u53cd\u8f6c\u4ee5preStart.Next\u4e3a\u5f00\u59cb\u4f4d\u7f6e\u3001end\u4e3a\u7ed3\u675f\u4f4d\u7f6e\u7684\u5b50\u94fe\n// \u5305\u62ec\u5185\u90e8\u94fe\u8868\u7684\u53cd\u8f6c\uff0c\u4ee5\u53ca\u5916\u90e8\u94fe\u8868\u7684\u8fde\u63a5\nfunc reverseSubLinkedList(preStart, end *ListNode) {\n    endNext := end.Next\n    if preStart.Next == end {\n        return\n    }\n    cur := preStart.Next\n    var prev, next *ListNode\n    for cur != endNext {\n        next = cur.Next\n        cur.Next = prev\n        prev = cur\n        cur = next\n    }\n    preStart.Next.Next = endNext\n    preStart.Next = end\n}\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    virtualHead := new(ListNode)\n    virtualHead.Next = head\n    preStart, end := virtualHead, virtualHead\n    for i := 0; i &lt; k; i++ {\n        end = end.Next\n    }\n    for {\n        reverseSubLinkedList(preStart, end)\n        for i := 0; i &lt; k; i++ {\n            preStart = preStart.Next\n        }\n        end = preStart\n        for i := 0; i &lt; k; i++ {\n            end = end.Next\n            if end == nil {\n                return virtualHead.Next\n            }\n        }\n    }\n}\n</code></pre> <p>\u672c\u9898\u975e\u5e38\u9002\u5408\u953b\u70bc\u94fe\u8868\u76f8\u5173\u7684\u7f16\u7801\u80fd\u529b\u3002</p>"},{"location":"hot100/matrix/LC240/","title":"LC240 - \u641c\u7d22\u4e8c\u7ef4\u77e9\u9635II","text":"SearchA2DMatrixII.go<pre><code>package Matrix\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n + m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc searchMatrix(matrix [][]int, target int) bool {\n    n, m := len(matrix), len(matrix[0])\n    if target &lt; matrix[0][0] || target &gt; matrix[n-1][m-1] {\n        return false\n    }\n    curX, curY := n-1, 0\n    for curX &gt;= 0 &amp;&amp; curX &lt; n &amp;&amp; curY &gt;= 0 &amp;&amp; curY &lt; m {\n        if matrix[curX][curY] &lt; target {\n            curY++\n        } else if matrix[curX][curY] &gt; target {\n            curX--\n        } else {\n            return true\n        }\n    }\n    return false\n}\n</code></pre> <p>\u53d6\u77e9\u9635\u5de6\u4e0b\u89d2\u5143\u7d20\u4e3a\u8d77\u59cb\u53c2\u8003\u70b9cur\uff0ccur &gt; target\u5219\u53ef\u4ee5\u5220\u9664cur\u6240\u5728\u884c\uff0ccur &lt; target\u5219\u53ef\u4ee5\u5220\u9664cur\u6240\u5728\u5217\u3002</p>"},{"location":"hot100/matrix/LC48/","title":"LC48 - \u65cb\u8f6c\u56fe\u50cf","text":"RotateImage.go<pre><code>package Matrix\n\nfunc rotate(matrix [][]int) {\n    n := len(matrix)\n    downHalf, upHalf := n/2, (n+1)/2\n    for i := 0; i &lt; downHalf; i++ {\n        for j := 0; j &lt; upHalf; j++ {\n            temp := matrix[i][j]\n            matrix[i][j] = matrix[n-1-j][i]\n            matrix[n-1-j][i] = matrix[n-1-i][n-1-j]\n            matrix[n-1-i][n-1-j] = matrix[j][n-1-i]\n            matrix[j][n-1-i] = temp\n        }\n    }\n}\n</code></pre> <p>\u6ce8\u610f\u4e24\u70b9: 1. \u5750\u6807\u53d8\u6362 2. \u77e9\u9635\u5206\u5757</p>"},{"location":"hot100/matrix/LC54/","title":"LC54 - \u87ba\u65cb\u77e9\u9635","text":"SpiralMatrix.go<pre><code>package Matrix\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n * m)\nfunc spiralOrder(matrix [][]int) []int {\n    n, m := len(matrix), len(matrix[0])\n    visited := make([][]bool, n)\n    for i := 0; i &lt; n; i++ {\n        visited[i] = make([]bool, m)\n    }\n    move := [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\n    curX, curY, curMove := 0, 0, 0\n    result := make([]int, 0)\n    for k := 0; k &lt; n*m; k++ {\n        result = append(result, matrix[curX][curY])\n        visited[curX][curY] = true\n        nextX := curX + move[curMove][0]\n        nextY := curY + move[curMove][1]\n        if nextX &gt;= 0 &amp;&amp; nextX &lt; n &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; m &amp;&amp; !visited[nextX][nextY] {\n            curX, curY = nextX, nextY\n        } else {\n            curMove = (curMove + 1) % 4\n            nextX = curX + move[curMove][0]\n            nextY = curY + move[curMove][1]\n            curX, curY = nextX, nextY\n        }\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/matrix/LC73/","title":"LC73 - \u77e9\u9635\u7f6e\u96f6","text":"SetMatrixZeroes.go<pre><code>package Matrix\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n * m), \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\nfunc setZeroes(matrix [][]int) {\n    n, m := len(matrix), len(matrix[0])\n    // firstRow: \u7b2c\u4e00\u884c\u662f\u5426\u88ab\u5237\u62100, firstCol: \u7b2c\u4e00\u5217\u662f\u5426\u88ab\u5237\u6210\u96f6, intersection: matrix[0][0]\u662f\u5426\u4e3a0\n    firstRow, firstCol, intersection := false, false, false\n    // (1) \u904d\u5386\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\uff0c\u521d\u59cb\u5316\u4e0a\u8ff0\u4e09\u4e2a\u6807\u8bb0\n    for i := 0; i &lt; m; i++ {\n        if matrix[0][i] == 0 {\n            firstRow = true\n        }\n    }\n    for i := 0; i &lt; n; i++ {\n        if matrix[i][0] == 0 {\n            firstCol = true\n        }\n    }\n    intersection = firstRow || firstCol\n    // (2) \u904d\u5386\u53f3\u4e0b\u89d2\u77e9\u9635\uff0c\u66f4\u65b0\u884c\u5217\u4ee3\u8868\u5143\u7d20\n    for i := 1; i &lt; n; i++ {\n        for j := 1; j &lt; m; j++ {\n            if matrix[i][j] == 0 {\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n            }\n        }\n    }\n    // (3) \u4f9d\u636e\u884c\u5217\u4ee3\u8868\u5143\u7d20\u7684\u503c\uff0c\u5237\u65b0\u53f3\u4e0b\u89d2\u77e9\u9635\n    for i := 1; i &lt; n; i++ {\n        for j := 1; j &lt; m; j++ {\n            if matrix[i][0] == 0 || matrix[0][j] == 0 {\n                matrix[i][j] = 0\n            }\n        }\n    }\n    // (4) \u4f9d\u636e\u4e0a\u8ff0\u4e09\u4e2a\u6807\u8bb0\uff0c\u5237\u65b0\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\n    if intersection {\n        matrix[0][0] = 0\n    }\n    if firstRow {\n        for i := 0; i &lt; m; i++ {\n            matrix[0][i] = 0\n        }\n    }\n    if firstCol {\n        for i := 0; i &lt; n; i++ {\n            matrix[i][0] = 0\n        }\n    }\n}\n</code></pre> <p>\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230\u7684\u662f\u7a7a\u95f4\u590d\u6742\u5ea6O(n + m)\u7684\u7b97\u6cd5\uff0c\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u884c\u6807\u8bb0\u6570\u7ec4\u548c\u5217\u6807\u8bb0\u6570\u7ec4\u3002\u800c\u4e0a\u8ff0\u7a7a\u95f4\u590d\u6742\u5ea6O(1)\u7684\u7b97\u6cd5\u5c31\u662f\u5c06\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u4f5c\u4e3a\u4e86\u5217\u6807\u8bb0\u6570\u7ec4\u548c\u884c\u6807\u8bb0\u6570\u7ec4\uff0c\u5177\u4f53\u8fc7\u7a0b\u89c1\u6ce8\u91ca\u3002</p>"},{"location":"hot100/slidingWindow/LC3/","title":"LC3 - \u65e0\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32","text":"LongestSubstringWithoutRepeatingCharacters.go<pre><code>package SlidingWindow\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(\u2223\u03a3\u2223) [\u2223\u03a3\u2223\u4e3a\u5b57\u7b26\u96c6\u5927\u5c0f]\nfunc lengthOfLongestSubstring(s string) int {\n    hashSet := make(map[byte]bool)\n    lbound, rbound, result := 0, 0, 0\n    for ; rbound &lt; len(s); rbound++ {\n        if !hashSet[s[rbound]] {\n            hashSet[s[rbound]] = true\n        } else {\n            result = max(result, rbound-lbound)\n            for ; s[lbound] != s[rbound]; lbound++ {\n                hashSet[s[lbound]] = false\n            }\n            lbound++\n        }\n    }\n    result = max(result, rbound-lbound)\n    return result\n}\n</code></pre>"},{"location":"hot100/slidingWindow/LC438/","title":"LC438 - \u627e\u51fa\u5b57\u7b26\u4e32\u4e2d\u6240\u6709\u5b57\u6bcd\u5f02\u4f4d\u8bcd","text":"FindAllAnagramsInAString.go<pre><code>package SlidingWindow\n\nfunc findAnagrams(s string, p string) []int {\n    ns, np := len(s), len(p)\n    if ns &lt; np {\n        return []int{}\n    }\n    result := []int{}\n    var pCount, sCount [26]int\n    for i := 0; i &lt; np; i++ {\n        pCount[p[i]-'a']++\n        sCount[s[i]-'a']++\n    }\n    if pCount == sCount {\n        result = append(result, 0)\n    }\n    for i := np; i &lt; ns; i++ {\n        sCount[s[i]-'a']++\n        sCount[s[i-np]-'a']--\n        if pCount == sCount {\n            result = append(result, i-np+1)\n        }\n    }\n    return result\n}\n</code></pre>"},{"location":"hot100/substring/LC239/","title":"LC239 - \u6ed1\u52a8\u7a97\u53e3\u6700\u5927\u503c","text":"SlidingWindowMaxium.go<pre><code>package Substring\n\nimport \"container/list\"\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(k)\nfunc maxSlidingWindow(nums []int, k int) []int {\n    result := make([]int, 0)\n    l := list.New()\n    for i := 0; i &lt; k; i++ {\n        for l.Len() &gt; 0 &amp;&amp; nums[i] &gt;= nums[l.Back().Value.(int)] {\n            l.Remove(l.Back())\n        }\n        l.PushBack(i)\n    }\n    result = append(result, nums[l.Front().Value.(int)])\n    for i := k; i &lt; len(nums); i++ {\n        if l.Front().Value.(int) == i-k {\n            l.Remove(l.Front())\n        }\n        for l.Len() &gt; 0 &amp;&amp; nums[i] &gt;= nums[l.Back().Value.(int)] {\n            l.Remove(l.Back())\n        }\n        l.PushBack(i)\n        result = append(result, nums[l.Front().Value.(int)])\n    }\n    return result\n}\n</code></pre> <p>\u5355\u8c03\u961f\u5217</p>"},{"location":"hot100/substring/LC560/","title":"LC560 - \u548c\u4e3aK\u7684\u5b50\u6570\u7ec4","text":"SubarraySumEqualsK.go<pre><code>package Substring\n\n// \u65f6\u95f4\u590d\u6742\u5ea6: O(n), \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\nfunc subarraySum(nums []int, k int) int {\n    nums = append([]int{0}, nums...)\n    prefixSum := make([]int, len(nums))\n    for i := 1; i &lt; len(nums); i++ {\n        prefixSum[i] = prefixSum[i-1] + nums[i]\n    }\n    // nums[i...j]\u7d2f\u52a0\u548c = prefixSum[j] - prefixSum[i - 1]\n    hashMap := make(map[int]int)\n    hashMap[0] = 1\n    result := 0\n    for i := 1; i &lt; len(nums); i++ {\n        result += hashMap[prefixSum[i]-k]\n        hashMap[prefixSum[i]]++\n    }\n    return result\n}\n</code></pre> <p>\u524d\u7f00\u548c+\u4e24\u6570\u4e4b\u548c</p>"},{"location":"hot100/substring/LC76/","title":"LC76 - \u6700\u5c0f\u8986\u76d6\u5b50\u4e32","text":"MinimumWindowSubstring.go<pre><code>package Substring\n\nimport \"math\"\n\nfunc minWindow(s string, t string) string {\n    hashMap := make(map[byte]int)\n    debt := 0\n    for i := 0; i &lt; len(t); i++ {\n        hashMap[t[i]]--\n        debt++\n    }\n    minLen := math.MaxInt\n    minPos := 0\n    for lbound, rbound := 0, 0; rbound &lt; len(s); rbound++ {\n        if hashMap[s[rbound]] &lt; 0 {\n            debt--\n        }\n        hashMap[s[rbound]]++\n        if debt == 0 {\n            for ; hashMap[s[lbound]] &gt; 0; lbound++ {\n                hashMap[s[lbound]]--\n            }\n            if rbound-lbound+1 &lt; minLen {\n                minLen = rbound - lbound + 1\n                minPos = lbound\n            }\n        }\n    }\n    if minLen == math.MaxInt {\n        return \"\"\n    }\n    return s[minPos : minPos+minLen]\n}\n</code></pre> <p>debt\u53d8\u91cf\u8bb0\u5f55\u603b\u503a\u52a1\uff0chashMap\u8bb0\u5f55\u5177\u4f53\u7684\u503a\u52a1\u8868\u3002\u7b2c\u4e00\u9636\u6bb5\u6ed1\u52a8\u7a97\u53e3\u4e0d\u65ad\u6269\u5927\uff0c\u76f4\u81f3\u603b\u503a\u52a1\u51cf\u5c0f\u4e3a0\u3002\u7b2c\u4e8c\u9636\u6bb5\u6ed1\u52a8\u7a97\u53e3\u6bcf\u6b21\u6269\u5927\u4e00\u683c(\u53f3\u8fb9\u754c\u5411\u53f3\u79fb\u52a8)\uff0c\u968f\u540e\u5c1d\u8bd5\u7f29\u5c0f(\u5de6\u8fb9\u754c\u5411\u53f3\u79fb\u52a8)\u3002</p>"}]}